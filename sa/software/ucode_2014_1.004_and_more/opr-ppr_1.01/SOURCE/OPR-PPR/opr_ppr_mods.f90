!     Last change:  MJT  13 Sep 2005    7:27 am

      MODULE OPR_PPR_VAR

        USE DATATYPES, ONLY            : LLIST
        USE GLOBAL_DATA, ONLY          : MAX_STRING_LEN
        CHARACTER(LEN=MAX_STRING_LEN) :: MSG
        CHARACTER(LEN=7)  :: PROGNAM
        CHARACTER(LEN=11) :: VERSION
        INTEGER           :: LENPNAM,MORE
        PARAMETER (PROGNAM='OPR-PPR',VERSION='VERSION 1.0',LENPNAM=12)
        DOUBLE PRECISION   :: VERYSMALL       ! DUMMY VARIABLE
        PARAMETER (VERYSMALL=0.0D0)           ! WAS 1.0D-20 AS TEST FOR CD MATRIX
        INTEGER ::  RUNFLAG                   ! RUNFLAG = -1: OPROMIT Ind obs
                                              ! RUNFLAG = -2: OPROMIT Grp obs
                                              ! RUNFLAG =  0: BASE_CASE
                                              ! RUNFLAG =  1: OPRADD Ind obs
                                              ! RUNFLAG =  2: OPRADD Grp obs
                                              ! RUNFLAG =  3: OPRADDNODE Node obs
                                              ! RUNFLAG = 11: PPR Ind params
                                              ! RUNFLAG = 12: PPR Grp params (auto  groups)
                                              ! RUNFLAG = 13: PPR Grp params (user  groups - inactive)
        DOUBLE PRECISION   :: TOLERANCE       ! TOLERANCE FOR TERMINATING ITERATIVE PPR WEIGHT CALCULATIONS
        DOUBLE PRECISION   :: CORRELTHRESH    ! PARAMETER CORRELATION THRESHOLD FOR _OPC/_PPC FILES
        INTEGER ::  ICORRELTHRESH             ! NUMBER OF ITEMS TO BE WRITTEN TO THE _OPC/_PPC FILES
        INTEGER ::  NPARPREDONLY              ! NUMBER OF PARAMETERS WITH SENSITIVITIES IN _SPU *ONLY*
        INTEGER ::  MAXNPPERG                 ! MAX NUM PARAMS PER GROUP FOR GROUPED PPR ANALYSES
        INTEGER ::  INUNIT = 81               ! INUNIT FOR VARIOUS FILES
        INTEGER ::  IOUT = 82                 ! UNIT FOR MAIN OPR-PPR OUTPUT FILE
        INTEGER ::  NPRED                     ! NUMBER OF PREDICTIONS
        INTEGER ::  NPPERG                    ! NUM PARAMS PER GROUP FOR GROUPED PPR ANALYSES
        INTEGER ::  MAXNEW                    ! MAX NUMBER OF OBS/PAR IN ADD ANALYSES
        INTEGER ::  NGC,NGM                   ! # GROUPS, # OBS OR PRIOR, WHICH MAY OCCUR IN CALCULATIONS
        INTEGER ::  MAXITER,NITER             ! MAX NO ITERATIONS TO SOLVE FOR PRIOR WEIGHT; ITERATION NUMBER
        INTEGER ::  IOPTLST,INODLST,IFILLST   ! LIST NUMBERS
        INTEGER ::  IPARAMPAIR(2)             ! INDICES OF PARAM PAIRS FOR _OPCNOD FILE
        INTEGER ::  MAXPGRP,MAXPRED,NPGRPUSE  ! MAX NO. OF PREDICTION GROUPS, MAX NO. OF PREDICTIONS IN A GROUP,NUMBER BEING USED
        PARAMETER  (TOLERANCE=1.0D-6,MAXNPPERG=5,MAXITER=1000,MAXPRED=60000,MAXPGRP=100)
        INTEGER ::  PGFLAG(MAXPGRP,MAXPRED)   ! FLAG FOR PREDICTION GROUP CALCULATIONS
	    INTEGER ::  MAXCALCS                  ! MAX NUMBER OF CALCULATIONS TO MAKE (*NOT* FOR MODE=OPRADDNODE)
        CHARACTER(LEN=10)  :: RUNMODE         ! OPROMIT,OPRADD,OPRADDNODE,OR PPR
        CHARACTER(LEN=100) :: AOPRIN,AOPROUT  ! MAIN INPUT/OUTPUT FILE NAMES
        CHARACTER(LEN=100) :: DMFNAM,WTFNAM,AVPFNAM,SUFNAM,SPUFNAM,SUNFNAM,CalibrationPredictionRoot,WTNFNAM,DMPFNAM
	    CHARACTER(LEN=100) :: SUPRIPFNAM,WTPRIPFNAM
        CHARACTER(LEN=100) :: SUPRIFNAM,WTPRIFNAM,GRIDSENSFILE,GRIDWTSFILE,PARFILE
        CHARACTER(LEN=10)  :: PREDGROUPS                 ! PREDICTION GROUPS: NO (DEFAULT) OR YES
        CHARACTER(LEN=5)   :: OBSGROUPS,PARGROUPS,GROUPS ! YES/NO
        CHARACTER(LEN=5)   :: BASECASE                   ! YES/NO
        CHARACTER(LEN=6)   :: FILEFORMAT                 ! FORMAT FOR THE NODE-SENSITIVITY CALCULATION OUTPUT
        CHARACTER(LEN=1)   :: BLANK
        LOGICAL            :: NODEWT,CONVERGED           ! WEIGHTS FOR NODES : FLAG FOR PPR CONVERGENCE
        LOGICAL            :: INIT,FC                    ! INTIAL PPR WT CALC : FINAL PPR CALC FOR A GROUP
        LOGICAL            :: GROUPDEFINE
	    LOGICAL            :: OBS_NAME_SEQUENCE          ! TRUE INDICATES SEQUENCE OF OBS TO BE ADDED IS SAME AS IN _SU FILE
        DOUBLE PRECISION   :: PERCENTREDUC,RDUMD
        CHARACTER(LEN=40), DIMENSION(2), TARGET  :: DUMCOL =   (/'KEYWORD   ','SUPPLIED  '/)
        CHARACTER(LEN=40), DIMENSION(2), TARGET  :: PREDCOL =  (/'PREDNAME  ','GROUPNAME '/)
        CHARACTER(LEN=40), DIMENSION(1), TARGET  :: PARCOL =   (/'PARAMNAME '/)
        CHARACTER(LEN=40), DIMENSION(4), TARGET  :: OBSCOL =   (/'OBSNAME   ','GROUPNAME ','STATISTIC ','STATFLAG  '/)
        CHARACTER(LEN=40), DIMENSION(4), TARGET  :: PRICOL =   (/'PARAMNAME ','TRANSFORM ','STATFLAG  ','STATISTIC '/)
        CHARACTER(LEN=12)  :: DEFGROUPINT,OPCNODOPTION
        INTEGER,ALLOCATABLE,DIMENSION(:)      :: NUMOBS       ! # OF OBS OR # OF PRIOR PER GROUP FOR GROUPED ANALYSES
        INTEGER,ALLOCATABLE,DIMENSION(:)      :: NUMPRED      ! # OF PRED PER GROUP FOR GROUPED ANALYSES
        LOGICAL,ALLOCATABLE,DIMENSION(:)      :: USEFLAGP     ! USEFLAG FOR PREDICTION GROUPS
        INTEGER,ALLOCATABLE,DIMENSION(:)      :: KSTP,KPER    ! FOR PROCESSING NODE SENSITIVITIES
        REAL(KIND=4),ALLOCATABLE,DIMENSION(:) :: PERTIM,TOTIM ! FOR PROCESSING NODE SENSITIVITIES
        REAL(KIND=4),ALLOCATABLE,DIMENSION(:) :: OMIT_DATA_VAL! FOR PROCESSING NODE SENSITIVITIES
	    REAL(KIND=4)                          :: OPRPPR_PRECISION  ! CHECK FOR EFFECTIVE ZERO TO PRECISION
	    CHARACTER(LEN=20),ALLOCATABLE,DIMENSION(:)    :: PNAMTMP1  ! THIS IS REALLY A DEPENDENT AS IT IS PRIOR
        DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:)   :: PREDONLYPRIOR_WT,PREDONLYPRIOR_STAT
        CHARACTER(LEN=6),ALLOCATABLE,DIMENSION(:)     :: PREDONLYPRIOR_STATFLAG
        TYPE(LLIST),POINTER :: PREDDAT_HEAD,PREDGRP_HEAD,PTR,PREDONLY_HEAD
	  !
	  ! ARRAYS FROM OPRPPR_CALC MOVED TO MODULE TO AVOID ALLOCATION WITHIN THE STACK
        DOUBLE PRECISION, ALLOCATABLE, DIMENSION(:,:) :: XTW,CMAT,AINV,D,ZCP,ZV
        !
        ! VARIABLES READ FROM _DM (OPR_PPR USES ONLY NDINC,NPERD,VAR)
        DOUBLE PRECISION   :: AIC,BIC,DTLA,HQ,KASHYAP,MLOFD,MLOFDP,STAT1,STAT2,STDERR,VAR
        INTEGER            :: ITERP,MPR,NDINC,NPE,NPERD,NPS,NOBS
	    CHARACTER(LEN=3)   :: ICONVERGE
        CHARACTER(LEN=12)  :: MODELLENGTH,MODELMASS,MODELNAME,MODELTIME

      END MODULE OPR_PPR_VAR

! --------------------------------------------

      SUBROUTINE OPRPPR_READ_OPTIONS()
      ! READ OPTION BLOCK DEFINING THE TYPE OF ANALYSIS
      USE GLOBAL_DATA, ONLY:    IVERB, MAX_STRING_LEN,MINVERB,MAXVERB
      USE UTILITIES, ONLY:      UTL_GETLINE,UTL_RWORD,UTL_CASE,UTL_STOP,UTL_WRITEBLOCK,UTL_READBLOCK,UTL_FILTER
      USE DATATYPES
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                       :: IERR,I_OPTIONS
      TYPE (LLIST), POINTER         :: TAIL,OPTIONS_HEAD
      CHARACTER(LEN=MAX_STRING_LEN) :: WORD1
20    FORMAT(/,1X,'OPTIONS BLOCK WAS NOT FOUND - DEFAULTS WILL BE USED (OPROMIT): ', &
             /,1X,'*- IF YOU INTENDED PROVIDING THE OPTIONS BLOCK CHECK SYNTAX -*')
30    FORMAT(/,1X,'RUNFLAG= ',I2,' (MODE=',A,')',/,3X,A)
40    FORMAT(/,1X,'RUNFLAG= ',I2,' (MODE=',A,'; GROUPS=',A,'):',2X,A)
50    FORMAT(/,1X,'STATISTICS WILL BE SUMMARIZED INTO PREDICTION GROUPS')
60    FORMAT(/,1X,'MAXCALCS = ',I4,': ONLY THE FIRST ',I4,' CALCULATIONS WILL BE MADE',/)
70    FORMAT(/,1X,'ADD-NODE SELECTED BUT OBSGROUPS="YES": OBSGROUPS SET TO "NO"')
80    FORMAT(3X,'PERCENTREDUC PROVIDED IS > 100.0 OR < 0.01 - RESET TO DEFAULT (10.0 PERCENT)')
90    FORMAT(3X,'PERCENTREDUC EQUATES TO PARAMETER STDEV REDUCTION OF ',1PG10.4,' PERCENT')
100   FORMAT(3X,'OPTIONS BLOCK PRESENT BUT ',A,' NOT FOUND - DEFAULT = ',A)
      ! READ OPR_INPUTS BLOCK (FLAGS/KEYWORDS)
      I_OPTIONS=0
      NULLIFY(OPTIONS_HEAD)   !swm: Nullify pointer 
      NULLIFY(TAIL)   !swm: Nullify pointer 
      RUNFLAG=-1          !DEFAULT
      RUNMODE= 'OPROMIT'  !DEFAULT
      CALL UTL_READBLOCK(2,'OPTIONS',DUMCOL,INUNIT,IOUT,'*',.FALSE.,OPTIONS_HEAD,TAIL,I_OPTIONS)
      ! IF THE OPTIONS BLOCK WAS PRESENT ECHO THEN PARSE
      IF(I_OPTIONS.GT.0) THEN
        IF (IVERB.GE.3) CALL UTL_WRITEBLOCK(OPTIONS_HEAD,IOUT)
        WORD1=BLANK
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'MODE',WORD1)
        IF(WORD1.NE.BLANK) CALL UTL_CASE(WORD1,RUNMODE,1)
        WORD1=BLANK
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'OBSGROUPS',WORD1)
        IF(WORD1.NE.BLANK) CALL UTL_CASE(WORD1,OBSGROUPS,1)
        WORD1=BLANK
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'PARGROUPS',WORD1)
        IF(WORD1.NE.BLANK) CALL UTL_CASE(WORD1,PARGROUPS,1)
        WORD1=BLANK
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'PREDGROUPS',WORD1)
        IF(WORD1.NE.BLANK) CALL UTL_CASE(WORD1,PREDGROUPS,1)
        IF(PREDGROUPS.EQ.'YES') WRITE(IOUT,50)
        WORD1=BLANK
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'BASECASE',WORD1)
        IF(WORD1.NE.BLANK) CALL UTL_CASE(WORD1,BASECASE,1)
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'VERBOSE',IVERB)
        IF (IVERB.LT.MINVERB) IVERB=MINVERB
        IF (IVERB.GT.MAXVERB) IVERB=MAXVERB
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'CORRELTHRESH',CORRELTHRESH)
        CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'MAXCALCS',MAXCALCS)
	  IF(MAXCALCS.GT.0) WRITE(IOUT,60) MAXCALCS,MAXCALCS
        IF(RUNMODE.EQ.'PPR') CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'PERCENTREDUC',PERCENTREDUC)
        IF(RUNMODE.EQ.'PPR') CALL UTL_FILTER(IERR,OPTIONS_HEAD,IOUT,'NPARPERGROUP',NPPERG)
        IF(RUNMODE.EQ.'OPROMIT'.AND.OBSGROUPS.EQ.'NO')   RUNFLAG=-1
        IF(RUNMODE.EQ.'OPROMIT'.AND.OBSGROUPS.EQ.'YES')  RUNFLAG=-2
        IF(RUNMODE.EQ.'OPRADD'.AND.OBSGROUPS.EQ.'NO')    RUNFLAG=+1
        IF(RUNMODE.EQ.'OPRADD'.AND.OBSGROUPS.EQ.'YES')   RUNFLAG=+2
        IF(RUNMODE.EQ.'OPRADDNODE') RUNFLAG=+3
        IF(RUNFLAG.EQ.3.AND.OBSGROUPS.EQ.'YES') THEN
          WRITE(IOUT,70)
          OBSGROUPS='NO'
        END IF
        IF(RUNMODE.EQ.'PPR'.AND.PARGROUPS.EQ.'NO')  RUNFLAG=11   !INDIVIDUAL PARAMETERS
        IF(RUNMODE.EQ.'PPR'.AND.PARGROUPS.EQ.'YES') RUNFLAG=12   !ALL POSSIBLE NPPERG-SIZE PARAMETER GROUPS
        IF(RUNFLAG.EQ.11) NPPERG=1                               !JUST FOR DIMENSIONING
        IF(RUNFLAG.EQ.12.AND.NPPERG.LT.0)           RUNFLAG=13   !USER-SUPPLIED PARAMETER GROUPS (NOT ACTIVATED IN V1.0)
        IF(RUNFLAG.EQ.12.AND.NPPERG.EQ.0)         &
                               CALL UTL_STOP('ERROR: GROUPS = TRUE BUT NParPerGroup = 0 - STOP (OPRPPR_READ_OPTIONS)')
        IF(RUNFLAG.EQ.12.AND.NPPERG.GT.MAXNPPERG) &
                               CALL UTL_STOP('ERROR: NParPerGroup > MAXNParPerGroup - STOP (OPRPPR_READ_OPTIONS)')
        ! IF RUNFLAG STILL ZERO SOMETHING WRONG
        IF(RUNFLAG.EQ.0) THEN
          CALL UTL_STOP('ERROR: AFTER READING "OPTIONS" RUNFLAG=0. CHECK RUNMODE - STOP (OPRPPR_READ_OPTIONS)')
        END IF
      ELSE
        ! OPTIONS BLOCK NOT FOUND REPORT WE WILL USE DEFAULTS
        WRITE(IOUT,20)
      END IF
       ! ECHO THE ANALYSIS THAT WILL BE PERFORMED
      IF(RUNFLAG.EQ.1)  WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(OBSGROUPS),'OPRADD INDIVIDUAL OBSERVATIONS'
      IF(RUNFLAG.EQ.2)  WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(OBSGROUPS),'OPRADD GROUPED OBSERVATIONS'
      IF(RUNFLAG.EQ.3)  WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(OBSGROUPS),'OPRADDNODE NODE-BASED OBSERVATIONS'
      IF(RUNFLAG.EQ.-1) WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(OBSGROUPS),'OPROMIT INDIVIDUAL OBSERVATIONS'
      IF(RUNFLAG.EQ.-2) WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(OBSGROUPS),'OPROMIT GROUPED OBSERVATIONS'
      IF(RUNFLAG.EQ.11) WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(PARGROUPS),'PPR FOR INDIVIDUAL PARAMETERS'
      IF(RUNFLAG.EQ.12) WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(PARGROUPS),'PPR FOR ALL POSSIBLE PARAMETER GROUPS'
      IF(RUNFLAG.EQ.13) WRITE(IOUT,40) RUNFLAG,TRIM(RUNMODE),TRIM(PARGROUPS),'PPR FOR USER-DEFINED PARAMETER GROUPS'
      IF(RUNFLAG.GE.11) WRITE(IOUT,90) PERCENTREDUC
      IF(PERCENTREDUC.GT.100.0D0.OR.PERCENTREDUC.LT.0.0D0) THEN
         PERCENTREDUC=10.0D0
         WRITE(IOUT,80)
      END IF
      IF(RUNFLAG.EQ.13) CALL UTL_STOP('USER-DEFINED PARAMETER GROUPS (RUNFLAG=13) NOT ACTIVATED')
      RETURN
      END SUBROUTINE OPRPPR_READ_OPTIONS

! --------------------------------------------

      SUBROUTINE OPRPPR_LOADDATA(OPRNAME,GRPNAME,OBSNAM,KDEP,NUMGPS)
      ! LOAD DATA TO BE USED IN THE ANALYSIS
      ! SHOULD ONLY LOAD DATA IN GROUPS THAT ARE IDENTIFIED AS "USE"
      USE GLOBAL_DATA, ONLY   :  IVERB,LENDNAM
      USE UTILITIES, ONLY     :  UTL_STOP,UTL_CASE
      USE DEPENDENTS, ONLY    :  NDEPGPS,USEFLAG,LLPTRDEP,GROUPNAM,GROUP
      USE OPR_PPR_VAR
      USE DATATYPES
      IMPLICIT NONE
      INTEGER                 :: NUMGPS,IERR,KDEP,N,I,J,NUMINGP(NDEPGPS)
      CHARACTER(LEN=3)        :: ANUMGPS
      CHARACTER(LEN=LENDNAM)  :: OPRNAME(NDEPGPS,KDEP),GRPNAME(NDEPGPS),OBSNAM(KDEP)
      TYPE (LNODE), POINTER   :: PIPTR
      CHARACTER(LEN=40)       :: UPGROUP, UPWORD1
  240 FORMAT(/,1X,'GROUP',I3,'   GROUP NAME:',1X,A20)
  250 FORMAT(/,1X,'OBSERVATIONS:',/,8(A20))
      ! INITIALIZE AND DEFAULTS
      NUMOBS=0
      NUMGPS=0
      DEFGROUPINT='DefaultObs'
      OPRNAME=''
      GRPNAME=''
      DO J=1,NDEPGPS
        IF(USEFLAG(J)) THEN
          ! COUNT THE "USE" GROUPS AND LOAD DUMMY GROUP NAMES
          NUMGPS=NUMGPS+1
          WRITE(ANUMGPS,'(I3)') NUMGPS
          GRPNAME(NUMGPS)='GROUP'//TRIM(ADJUSTL(ANUMGPS))
        END IF
      END DO
      I = 0
      IERR = 0
      NUMINGP=0
      PTR => LLPTRDEP
      DEPENDENT: DO
        IF (.NOT. ASSOCIATED(PTR)) EXIT DEPENDENT  ! Pointer valid?
        I = I+1
        PIPTR => PTR%LHEAD
        GROUPDEFINE = .FALSE.
        ! Traverse the entries for this dependent
        INFO: DO
          IF (.NOT. ASSOCIATED(PIPTR)) THEN
            IF (.NOT. GROUPDEFINE) THEN
              GRPNAME(I) = DEFGROUPINT
              CALL UTL_CASE(DEFGROUPINT,UPGROUP,1)
              FINDGPDEF: DO J=1,NDEPGPS
                CALL UTL_CASE(GROUPNAM(J),UPWORD1,1)
                IF (UPGROUP == UPWORD1) THEN
                  NUMINGP(J) = NUMINGP(J)+1
                  IF(USEFLAG(J)) THEN
                    NUMOBS(J)=NUMOBS(J)+1
                    OPRNAME(J,NUMOBS(J))=OBSNAM(I)
                  END IF
                ENDIF
              ENDDO FINDGPDEF
            ENDIF
            !40 CONTINUE
            EXIT INFO
          ENDIF
          IF (PIPTR%KEYWORD == 'GROUPNAME') THEN
            IF (.NOT. GROUPDEFINE) THEN
              GROUP(I) = PIPTR%VALUE
              GROUPDEFINE = .TRUE.
              CALL UTL_CASE(PIPTR%VALUE,UPGROUP,1)
              FINDGP: DO J=1,NDEPGPS
                CALL UTL_CASE(GROUPNAM(J),UPWORD1,1)
                IF (UPGROUP == UPWORD1) THEN
                  NUMINGP(J) = NUMINGP(J)+1
                  IF(USEFLAG(J)) THEN
                    NUMOBS(J)=NUMOBS(J)+1
                    OPRNAME(J,NUMOBS(J))=OBSNAM(I)
                  END IF
                  GOTO 50
                ENDIF
              END DO FINDGP
            ENDIF
            50 CONTINUE
          ENDIF
          PIPTR => PIPTR%NEXTNODE      ! Get pointer to next entry
        END DO INFO
        PTR => PTR%NEXTLIST            ! Get pointer to next dependent
      END DO DEPENDENT
      !
      RETURN !OKAY
      END SUBROUTINE OPRPPR_LOADDATA

! --------------------------------------------

      SUBROUTINE OPRPPR_LOADPRED(PGRPNAME,PREDNAM,I_PREDGRP,I_PREDDAT)
      ! NOTE - CURRENTLY USEFLAG=NO PERFORMS DIFFERENTLY FOR PREDICTION GROUPS
      !        THAT IS - THE CALCULATIONS ARE STILL MADE: ONLY THE SUMMARY CHANGES
      !        IF WE WANT TO IMPLEMENT FULL FUNCTIONALITY WE MUST
      !        LOAD THE PGRPNAME ARRAY TO BE OF DIMENSIONS 'NPGRPUSE'
      !        SO THAT THE BINARY FILE REPORTING OPTIONS FUNCTION
      USE GLOBAL_DATA, ONLY   :  IVERB,LENDNAM
      USE UTILITIES, ONLY     :  UTL_STOP,UTL_CASE
      USE OPR_PPR_VAR
      USE DATATYPES
      IMPLICIT NONE
      INTEGER                 :: I_PREDGRP,I_PREDDAT,I,J
      CHARACTER(LEN=LENDNAM)  :: PGRPNAME(I_PREDGRP),PREDNAM(I_PREDDAT)
      TYPE (LNODE), POINTER   :: PIPTR
      CHARACTER(LEN=40)       :: UPGROUP, UPWORD1
  200 FORMAT(/,1X,'ERROR: ONLY ONE "USE" GROUP IDENTIFIED - PREDGROUPS SHOULD = NO (OPRPPR_LOADPRED)')
  240 FORMAT(/,1X,'GROUP',I3,'   GROUP NAME:',1X,A20)
  250 FORMAT(/,1X,'PREDICTIONS:',/,8(A20))
      ! INITIALIZE AND DEFAULTS
      DEFGROUPINT='DefaultPred'
      PGFLAG=0
      I = 0
      NUMPRED=0
      PTR => PREDDAT_HEAD
      PREDICTIONS: DO
        IF (.NOT. ASSOCIATED(PTR)) EXIT PREDICTIONS  !POINTER NOT VALID?
        I = I+1
        PIPTR => PTR%LHEAD
        GROUPDEFINE = .FALSE.
        ! Traverse the entries for this dependent
        INFO: DO
          IF (.NOT. ASSOCIATED(PIPTR)) THEN
            IF (.NOT. GROUPDEFINE) THEN
              CALL UTL_CASE(DEFGROUPINT,UPGROUP,1)
              FINDGPDEF: DO J=1,I_PREDGRP
                CALL UTL_CASE(PGRPNAME(J),UPWORD1,1)
                IF (UPGROUP == UPWORD1) THEN
                  IF(USEFLAGP(J)) THEN
                    NUMPRED(J)=NUMPRED(J)+1
                    PGFLAG(J,I)=1      !FLAG FOR PREDICTION GROUP CALCS
                  END IF
                ENDIF
              ENDDO FINDGPDEF
            ENDIF
            40 CONTINUE
            EXIT INFO
          ENDIF
          IF (PIPTR%KEYWORD == 'GROUPNAME') THEN
            IF (.NOT. GROUPDEFINE) THEN
              GROUPDEFINE = .TRUE.
              CALL UTL_CASE(PIPTR%VALUE,UPGROUP,1)
              FINDGP: DO J=1,I_PREDGRP
                CALL UTL_CASE(PGRPNAME(J),UPWORD1,1)
                IF (UPGROUP == UPWORD1) THEN
                  IF(USEFLAGP(J)) THEN
                    NUMPRED(J)=NUMPRED(J)+1
                    PGFLAG(J,I)=1      !FLAG FOR PREDICTION GROUP CALCS
                  END IF
                  GOTO 50
                ENDIF
              END DO FINDGP
            ENDIF
            50 CONTINUE
          ENDIF
          PIPTR => PIPTR%NEXTNODE      ! Get pointer to next entry
        END DO INFO
        PTR => PTR%NEXTLIST            ! Get pointer to next PREDICTION
      END DO PREDICTIONS
      NPGRPUSE=0
      DO J=1,I_PREDGRP
        IF(USEFLAGP(J)) NPGRPUSE=NPGRPUSE+1
      END DO
      RETURN !OKAY
      END SUBROUTINE OPRPPR_LOADPRED

! --------------------------------------------

      SUBROUTINE OPRPPR_READB(PARVAL,PARNAM,LN)
      ! READS PARTS OF THE MODFLOW-2000 "_b" FILE TO GET PARAMETER VALUES
      USE GLOBAL_DATA, ONLY:           IVERB, MAX_STRING_LEN,LENDNAM
      USE UTILITIES, ONLY:             UTL_STOP,UTL_RWORD,UTL_CASE,UTL_SAMENAME
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                       :: LN(NPERD),ISENS,N,I,IOUB,IMATCH,ISET,LLN
      DOUBLE PRECISION              :: PARVAL(NPERD),R,B,BL,BU,BSCAL
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD),PARNAMTEMP,PARNAMTEMPUP,PARNAMUP
      CHARACTER(LEN=MAX_STRING_LEN) :: LINE,WORD1,UPWORD1
      LOGICAL                       :: FINAL,SAME
10    FORMAT(/,1X,'READING _B FILE ',A,' FOR PARAMETER VALUES TO UNSCALE 1% SCALED SENSITIVITIES')
20    FORMAT(1X,'PARAMETER ESTIMATION DID NOT CONVERGE - USING FINAL PARAMETER ESTIMATES')
30    FORMAT(1X,A20,1X,1PG12.6)
      MSG=BLANK
      MSG='PROBLEM PROCESSING PARAMETER VALUES FROM FILE ' //TRIM(ADJUSTL(PARFILE))//' (OPRPPR_READB)'
      ! REPORT MESSAGE REGARDING OPTIMIZED PARAMETER VALUES
      WRITE(IOUT,10) TRIM(ADJUSTL(PARFILE))
      ISET=0
      FINAL=.FALSE.
      IOUB=88
      IMATCH=0
      ! START ROUTINE
      CALL OPRPPR_OPENFILE(IOUB,3,PARFILE,IOUT)
      READB: DO
        READ(IOUB,'(A)',END=50,ERR=90) LINE
        CALL UTL_CASE(LINE,UPWORD1,1)
        IF(INDEX(UPWORD1,'FINAL PARAMETER ESTIMATES').GT.0) THEN
          WRITE(IOUT,20)
          FINAL=.TRUE.
          !EXIT READB
        ELSEIF(INDEX(UPWORD1,'PARAMETER-VALUE SET').GT.0) THEN
          ISET=ISET+1
        END IF
      END DO READB
50    CONTINUE
      ! READ IN REVERSE AND MATCH NAMES THEN IT DOES NOT MATTER WHAT NPLIST WAS
      BACKSPACE(IOUB,ERR=90)
      READPVAL: DO
        BACKSPACE(IOUB,ERR=90)
        READ(IOUB,*,END=90,ERR=90) PARNAMTEMP,ISENS,LLN,B,BL,BU,BSCAL
        CALL UTL_CASE(PARNAMTEMP,PARNAMTEMPUP,1)
        DO N=1,NPERD-NPARPREDONLY
          CALL UTL_CASE(PARNAM(N),PARNAMUP,1)
          IF(UTL_SAMENAME(PARNAMTEMPUP,PARNAMUP)) THEN
            PARVAL(N)=B
            LN(N)=LLN
            IF (LN(N).LE.0) THEN
              IF(B.LT.BSCAL) PARVAL(N)=BSCAL
            END IF
            IMATCH=IMATCH+1
            IF(IMATCH.EQ.NPERD-NPARPREDONLY)	EXIT READPVAL
          END IF
        END DO
        BACKSPACE(IOUB,ERR=90)
      END DO READPVAL
      CALL OPRPPR_OPENFILE(IOUB,2,PARFILE,IOUT)
      ! REPORT THE VALUE TO BE USED FOR THE SCALING
      WRITE(IOUT,'(1X,A)')'PARAMETER SCALING VALUES'
      DO N=1,NPERD-NPARPREDONLY
        WRITE(IOUT,30) PARNAM(N),PARVAL(N)
      END DO
      RETURN ! OKAY
90    CALL UTL_STOP(TRIM(MSG))
      END SUBROUTINE OPRPPR_READB

! --------------------------------------------

      SUBROUTINE OPRPPR_READGSF(PARNAM,XOBN,NROW,NCOL,NLAY,NTIMES,TOTNEW,PARVAL,LN,TNAME,I_OMIT)
      ! READS SENSITIVITY ARRAYS: READS AS 2D ARRAYS AND UNSCALES EACH IN TURN
      USE GLOBAL_DATA, ONLY:           IVERB, MAX_STRING_LEN,LENDNAM
      USE UTILITIES, ONLY:             UTL_STOP,UTL_RWORD,utl_case,UTL_CHAR2NUM,UTL_SAMENAME,UTL_NUM2CHAR
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                       :: INGSF,N,ILAY,IERR,I,J,K,LN(NPERD),ILEN,M,I_OMIT,IO
      INTEGER                       :: IARRAYS,NT,NCOL,NROW,NLAY,JCOL(NCOL),IROW(NROW)
      INTEGER                       :: IGRDSEN,NARRAYS,TOTNEW,NTIMES
      DOUBLE PRECISION              :: PARVAL(NPERD)
      CHARACTER(LEN=LENDNAM)        :: TNAME(TOTNEW)
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD),PNAME
      CHARACTER(LEN=16)             :: TEXT
      CHARACTER(LEN=3)              :: AINT
      DOUBLE PRECISION              :: XOBN(NPERD,TOTNEW)
      REAL(KIND=4)                  :: SNEW(NCOL,NROW)
      CHARACTER(LEN=MAX_STRING_LEN) :: WORD1,UPWORD1
10    FORMAT(/,1X,'READING FILE ',A,' FOR ONE-PERCENT SCALED SENSITIVIES: ')
      ! REPORT MESSAGE REGARDING ONE-PERCENT SCALED SENSITIVITIES
      WRITE(IOUT,10) TRIM(ADJUSTL(GridSensFile))
      ! INITIALIZE
      INGSF = 89
      NARRAYS = (TOTNEW*(NPERD-NPARPREDONLY))/(NROW*NCOL)
      IARRAYS=0
      TNAME='N   _   _   _   _   '
      PERTIM =0.0
      TOTIM =0.0
      ! START ROUTINE
      IF(FILEFORMAT.EQ.'ASCII') CALL OPRPPR_OPENFILE(INGSF,1,GridSensFile,IOUT)   !OPEN ASCII FILE
      IF(FILEFORMAT.EQ.'TABLE') CALL OPRPPR_OPENFILE(INGSF,1,GridSensFile,IOUT)   !OPEN TABLE FILE
      IF(FILEFORMAT.EQ.'BINARY') CALL OPRPPR_OPENFILE(INGSF,5,GridSensFile,IOUT)  !OPEN BINARY FILE
      ! READ THE FILE
      DO NT=1,NTIMES
        DO N=1,NPERD-NPARPREDONLY   !DONT READ THOSE WITH NO INFORMATION
          IGRDSEN=0
          DO K=1,NLAY
            SNEW = 0.0
            PNAME = ''
            TEXT = ''
            ! READ ARRAY HEADERS FIRST FOR CHECKING
20          IF(FILEFORMAT.EQ.'TABLE') THEN
              READ(INGSF,'(A)',END=99,ERR=100) WORD1
              IF(WORD1.EQ.'') GOTO 20
              CALL UTL_CASE(WORD1,UPWORD1,1)
              IF(INDEX(UPWORD1,'SENS. IN LAYER').EQ.0) GOTO 20
              IF(INDEX(UPWORD1,'FOR CROSS SECTION').GT.0) &
                CALL UTL_STOP('SENSITIVITIES IN CROSS SECTION NOT SUPPORTED - STOP (OPRPPR_READGSF)')
              PNAME(1:10)=UPWORD1(3:12)
              PNAME=ADJUSTL(PNAME)
              CALL UTL_CHAR2NUM(IERR,UPWORD1(29:31),ILAY)
              CALL UTL_CHAR2NUM(IERR,UPWORD1(53:55),KSTP(NT))
              CALL UTL_CHAR2NUM(IERR,UPWORD1(75:77),KPER(NT))
            END IF
            IF(FILEFORMAT.EQ.'ASCII') READ(INGSF,*,END=99,ERR=100) &
                                      KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),PNAME,TEXT,NCOL,NROW,ILAY
            ILEN=LEN(TRIM(PARNAM(N)))
            IF(FILEFORMAT.EQ.'BINARY') READ(INGSF,END=99,ERR=100) &
                                       KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT), &
                                       PNAME(1:ILEN),TEXT(ILEN+1:16),NCOL,NROW,ILAY
            IF(.NOT.UTL_SAMENAME(PNAME,PARNAM(N))) THEN
              WRITE(IOUT,30) TRIM(ADJUSTL(PNAME)),TRIM(ADJUSTL(PARNAM(N)))
30            FORMAT(//,1X,'PARAMETER(S) LISTED IN GRID SENSITIVITY FILE (',A,') INCONSISTENT WITH', &
                      /,1X,'PARAMETER(S) LISTED IN _SU SENSITIVITY FILE (',A,') - STOP (OPRPPR_READGSF)')
              CALL UTL_STOP(' ')
            END IF
            WRITE(IOUT,40) PARNAM(N),ILAY,KSTP,KPER
40          FORMAT(1X,'PROCESSING ',A,' IN LAYER',I3,' TIME STEP',I3,' STRESS PERIOD',I3)
            IF(FILEFORMAT.EQ.'TABLE') THEN
              ! READ HEADERS AND COLUMN NUMBERS THEN ARRAY
              READ(INGSF,*,END=99,ERR=100) !UNDERLINE
              READ(INGSF,*,END=99,ERR=100) !BLANK LINE
              READ(INGSF,*,END=99,ERR=100) (JCOL(J),J=1,NCOL)
              READ(INGSF,*,END=99,ERR=100) !UNDERLINE
            END IF
            ! READ ONE-PERCENT SCALED SENSITIVITIES AND UNSCALE USING PARAMETER VALUE FROM SEN FILE
            IF(FILEFORMAT.EQ.'ASCII') READ(INGSF,*,END=99,ERR=100) ((SNEW(J,I),J=1,NCOL),I=1,NROW)
            IF(FILEFORMAT.EQ.'BINARY') READ(INGSF,END=99,ERR=100)  ((SNEW(J,I),J=1,NCOL),I=1,NROW)
            IF(FILEFORMAT.EQ.'TABLE') READ(INGSF,*,END=99,ERR=100) (IROW(I),(SNEW(J,I),J=1,NCOL),I=1,NROW)
            DO I=1,NROW
              DO J=1,NCOL
		      IF(I_OMIT.GT.0)THEN                                     !IGNORE THIS SENSITIVITY AS OMIT_DATA?
				DO IO=1,I_OMIT
				  IF(SNEW(J,I).EQ.OMIT_DATA_VAL(IO)) SNEW(J,I)=0.0D0
                  END DO
                END IF
			END DO
		  END DO
		  ! ECHO SENSITIVITIES TO BE USED: SHOULD MAKE THIS PRETTIER
            IF(IVERB.GE.5) THEN
              WRITE(IOUT,*) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),PNAME,TEXT,NCOL,NROW,ILAY
              DO I=1,NROW
                WRITE(IOUT,'(10(F16.8))') (SNEW(J,I),J=1,NCOL)
              END DO
            END IF
            DO I=1,NROW
              DO J=1,NCOL                                               !UNSCALE THE SENSITIVITIES
                IF(LN(N).GT.0) SNEW(J,I)=SNEW(J,I)*100.0D0              !LOG-TRANSFORMED PARAMETERS
                IF(LN(N).LE.0) SNEW(J,I)=SNEW(J,I)*100.0D0/PARVAL(N)    !NON-TRANSFORMED PARAMETERS
                IGRDSEN=IGRDSEN + 1 + ((NT-1)*NLAY*NCOL*NROW)
                XOBN(N,IGRDSEN)= DBLE(SNEW(J,I))
                ! BUILD TNAME HERE FOR USE IN WRITE OUTS
                CALL UTL_NUM2CHAR(KPER(NT),AINT,3)
                TNAME(IGRDSEN)(2:4)=ADJUSTR(AINT)
                CALL UTL_NUM2CHAR(KSTP(NT),AINT,3)
                TNAME(IGRDSEN)(6:8)=ADJUSTR(AINT)
                CALL UTL_NUM2CHAR(J,AINT,3)
                TNAME(IGRDSEN)(10:12)=ADJUSTR(AINT)
                CALL UTL_NUM2CHAR(I,AINT,3)
                TNAME(IGRDSEN)(14:16)=ADJUSTR(AINT)
                CALL UTL_NUM2CHAR(K,AINT,3)
                TNAME(IGRDSEN)(18:20)=ADJUSTR(AINT)
                DO M=1,LENDNAM
                  IF(TNAME(IGRDSEN)(M:M).EQ.' ') TNAME(IGRDSEN)(M:M)='0'!COULD MAKE NEW NUM2CHAR TO INCLUDE LEADING ZEROS
                END DO
              END DO
            END DO
            IARRAYS=IARRAYS+1
          END DO
        END DO
      END DO
      IF(IARRAYS.NE.NARRAYS) THEN
        WRITE(IOUT,50) NARRAYS,IARRAYS
50      FORMAT(//,1X,'NARRAYS ',I4,' DOES NOT EQUAL IARRAYS ',I4,' - STOP (OPRPPR_READGSF)')
        CALL UTL_STOP(',')
      END IF
      CALL OPRPPR_OPENFILE(INGSF,2,GRIDSENSFILE,IOUT)  !CLOSE THE GRID SENSITIVITY FILE
      RETURN ! OKAY
90    WRITE(IOUT,91) TRIM(ADJUSTL(GridSensFile))
91    FORMAT(//,1X,'ERROR: PARAMETERS LISTED IN ',A,' DO NOT MATCH OR ARE IN DIFFERENT SEQUENCE', &
              /,1X,'       TO THOSE LISTED IN THE SENSITIVITY (_SU) ARRAY - STOP (OPRPPR_READGSF)')
      GOTO 100
99    WRITE(IOUT,*) 'ERROR: UNEXPECTED END TO GRID SENSITIVITIES FILE - STOP (READGSF)'
100   CALL UTL_STOP('ERROR: PROBLEM ENCOUNTERED READING GRID SENSTIVITIES - STOP (OPRPPR_READGSF)')
      END SUBROUTINE OPRPPR_READGSF

! --------------------------------------------

      SUBROUTINE OPRPPR_UPDATEMATS(MAXOB,XSWPLOC,XOBN,TOTNEW,WTMALL,ITER,WTN, &
                                   TNAME,WTM,PARNAM,OBSNAME,PRIORWT, &
						         PARIND,IVC,NG,OPRNAME,PRIORNAME,TEMPNAME,NNZF)
      ! UPDATE THE WTN AND XOBN MATRICES THAT ARE USED IN CALCULATIONS
      USE GLOBAL_DATA, ONLY:        IVERB, MAX_STRING_LEN,LENDNAM
      USE DATATYPES
      USE UTILITIES, ONLY:          UTL_STOP,UTL_MATMUL,UTL_WRITECDMATRIX,UTL_GETPOS,UTL_GETVAL
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER(KIND=8)               :: IPOS8
      INTEGER                       :: MAXOB,I,J,K,IPOS,ITER,N,M,NALLNZ,IVC,NG,&
                                       TOTNEW,NR,NC,NNZ,IC,ICOLD,NNEW,ISUB,IADD,NINDEX(TOTNEW),NNZF
      DOUBLE PRECISION              :: XOBN(NPERD,TOTNEW),PRIORWT(3,NPERD),XSWPLOC(NPERD,MAXOB),RTIME
      TYPE (CDMATRIX)               :: WTMALL,WTN,WTM
      CHARACTER(LEN=LENDNAM)        :: TNAME(TOTNEW),TEMPNAME(MAXOB),OBSNAME(NDINC),OPRNAME(NGC,NGM), &
                                       PRIORNAME(MPR+NPARPREDONLY)
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD)
      CHARACTER(LEN=MAX_STRING_LEN) :: LINE
      LOGICAL                       :: NOTSYM
      INTEGER                       :: NUMNONZ,PARIND(IVC,NPPERG)
10    FORMAT(/,1X,'WARNING: MODIFIED WEIGHT MATRIX IS NOT SYMMETRIC - SYMMETRY HAS BEEN', &
               1X,'ASSURED USING ONLY UPPER TRIANGLE - CHECK INPUT FILES (OPRPPR_UPDATEMATS) ')
20    FORMAT(/,1X,'PRINTING AUGMENTED SENSITIVITY MATRIX "X" FOR ITERATION ',I5,/)
      ! NOTE: NINDEX ARRAY USED TO STORE INDEX OF ADDED OBSERVATIONS SO CHECKS CAN BE PERFORMED TO ENSURE THAT
      ! WHEN GROUPS ARE USED OFF-DIAGONALS (CORRELATION) IN THE ADDED WEIGHTS IS HONORED (RUNFLAG = +2 ONLY)
	  NOBS = NDINC
	! MODIFIED FOR LARGE CASES: PASS NNZ FOR USE LOCALLY
	  NNZ=NNZF !NNZ = NUMNONZ(WTM,NOBS+MPR+NPARPREDONLY,NOBS+MPR+NPARPREDONLY)
	!
	! CLEAR ENTRIES OF TEMPNAME ARRAY FOR PRINTING MATRICES
      TEMPNAME(NOBS+MPR+NPARPREDONLY+1:MAXOB)='PLACEHOLDER '
	!
	! SET UP THE WEIGHT MATRIX ADDITIONAL ROWS AND COLS
	  IF(RUNFLAG.EQ.1.OR.RUNFLAG.EQ.3.OR.RUNFLAG.EQ.11) THEN
        !PLACE "VERYSMALL" WEIGHT IN LAST ROW/COL AS HOLDER
        IPOS8=INT(NOBS+MPR+NPARPREDONLY+1,8)*INT(NOBS+MPR+NPARPREDONLY+1,8)
        !write(*,*) 'IPOS8: ',ipos8
        WTMALL%NNZ = NNZ+1
        WTMALL%IPOS(NNZ+1) = IPOS8
        WTMALL%DVAL(NNZ+1) = VERYSMALL
        WTMALL%ICOL(NNZ+1) = NOBS+MPR+NPARPREDONLY+1
      ELSEIF(RUNFLAG.EQ.2.OR.RUNFLAG.EQ.12) THEN
        !PLACE VERYSMALL WEIGHT(S) IN MAXNEW ROWS&COLS OF ENTRIES AS HOLDERS
        WTMALL%NNZ = NNZ+(MAXNEW*MAXNEW)
        NR=NDINC+MPR+NPARPREDONLY+MAXNEW
        NC=NDINC+MPR+NPARPREDONLY+MAXNEW
        ICOLD=0
        NALLNZ=NNZ
        DO N=NDINC+MPR+NPARPREDONLY+1,NR   !ROWS
          DO M=NDINC+MPR+NPARPREDONLY+1,NC !COLS
            NALLNZ=NALLNZ+1
            IPOS = (N-1)*(NR)+M
            WTMALL%IPOS(NALLNZ) = IPOS
            WTMALL%DVAL(NALLNZ) = VERYSMALL
            IC = (IPOS-1)/(NR)+1
            IF (IC.NE.ICOLD) WTMALL%ICOL(IC) = NALLNZ
            ICOLD = IC
          END DO
        END DO
      END IF
	  NNEW= 0
      IF(ITER.EQ.0.AND.IVERB.GE.3) THEN
        WRITE(IOUT,20) ITER
        CALL OPRPPR_WRITEMATRIX(IOUT,MAXOB,NPERD,TEMPNAME,PARNAM,XSWPLOC)
      END IF
      !
      ! IF BASE CASE RETURN
      IF(ITER.EQ.0) RETURN
      !
      ! ADJUST XSWPLOC AND/OR WTPALL DEPENDING ON RUNFLAG
      ISUB=0
      IADD=0
      IF (RUNFLAG.EQ.-1) THEN !ITER IS THE OBSERVATION WE ARE ELIMINATING
        NNEW  =0
        DO K=1,NOBS
          IF(TRIM(ADJUSTL(OPRNAME(1,ITER))).EQ.TRIM(ADJUSTL(OBSNAME(K)))) THEN
            ISUB=ISUB+1
            DO I=1,NOBS ! ZERO THE WEIGHTS IN ROWS AND COLS
              IF(UTL_GETPOS(WTMALL,K,I).GT.0) WTMALL%DVAL(UTL_GETPOS(WTMALL,K,I)) = VERYSMALL
              IF(UTL_GETPOS(WTMALL,I,K).GT.0) WTMALL%DVAL(UTL_GETPOS(WTMALL,I,K)) = VERYSMALL
            END DO
          END IF
        END DO
        IF(ISUB.NE.1)THEN
          LINE='ERROR: PROBLEM ENCOUNTERED OMITTING OBSERVATION - CHECK INPUTS (OPRPPR_UPDATEMATS)'
          CALL UTL_STOP(LINE)
        END IF
      ELSEIF (RUNFLAG.eq.-2) then !ITER IS THE GROUP WE ARE ELIMINATING
        NNEW  =0
        DO M=1,NUMOBS(ITER)
          DO K=1,NOBS
            IF(TRIM(ADJUSTL(OPRNAME(ITER,M))).EQ.TRIM(ADJUSTL(OBSNAME(K)))) THEN
              ISUB=ISUB+1
              DO I=1,NOBS         !ZERO THE WEIGHTS IN ROWS AND COLS
                IF(UTL_GETPOS(WTMALL,K,I).GT.0) WTMALL%DVAL(UTL_GETPOS(WTMALL,K,I)) = VERYSMALL
                IF(UTL_GETPOS(WTMALL,I,K).GT.0) WTMALL%DVAL(UTL_GETPOS(WTMALL,I,K)) = VERYSMALL
              END DO
            END IF
          END DO
        END DO
        IF(ISUB.NE.numobs(iter))THEN
          LINE='ERROR: PROBLEM ENCOUNTERED OMITTING OBSERVATIONS - CHECK INPUTS (OPRPPR_UPDATEMATS)'
          CALL UTL_STOP(LINE)
        END IF
      ELSEIF (RUNFLAG.EQ.1) THEN !ITER IS THE OBSERVATION WE ARE ADDING
        NNEW = 1
	    IF(OBS_NAME_SEQUENCE)THEN
          DO I=1,NPERD
            XSWPLOC(I,NOBS+MPR+NPARPREDONLY+1) = XOBN(I,ITER)
          END DO
          WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+1,NOBS+MPR+NPARPREDONLY+1)) = UTL_GETVAL(WTN,ITER,ITER)
          TEMPNAME(NOBS+MPR+NPARPREDONLY+1)=TNAME(ITER)
	    ELSE
          DO M=1,TOTNEW             !CHECK SEQUENCE OF NAMES THEN ADD SENSITIVITIES INTO XSWPLOC
            IF(TRIM(ADJUSTL(OPRNAME(1,ITER))).EQ.TRIM(ADJUSTL(TNAME(M)))) THEN
              IADD=IADD+1
              DO I=1,NPERD
                XSWPLOC(I,NOBS+MPR+NPARPREDONLY+1) = XOBN(I,M)
              END DO
              WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+1,NOBS+MPR+NPARPREDONLY+1)) = UTL_GETVAL(WTN,M,M)
              TEMPNAME(NOBS+MPR+NPARPREDONLY+1)=TNAME(M)
            END IF
		    IF(IADD.EQ.1) EXIT
	      END DO
          IF(IADD.NE.1)THEN
            LINE='ERROR: PROBLEM ENCOUNTERED ADDING NEW OBSERVATION - CHECK INPUTS (OPRPPR_UPDATEMATS)'
            CALL UTL_STOP(LINE)
          END IF
	    END IF
      ELSEIF (RUNFLAG.eq.2) then !ITER IS THE GROUP WE ARE ADDING
        NNEW = NUMOBS(ITER)
        NINDEX = 0  !IS AN ARRAY
        ! ADD SENSITIVITIES INTO XSWPLOC: CHECK SEQUENCE OF NAMES
        DO N=1,NUMOBS(ITER)
          DO M=1,TOTNEW
            IF(TRIM(ADJUSTL(OPRNAME(ITER,N))).EQ.TRIM(ADJUSTL(TNAME(M)))) THEN
              IADD=IADD+1
              NINDEX(M)=N
              DO I=1,NPERD
                XSWPLOC(I,NOBS+MPR+NPARPREDONLY+N) = XOBN(I,M)
              END DO
              ! ADD DIAGONAL WEIGHT FOR THIS OBSERVATION INTO WTMALL
              WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+N,NOBS+MPR+NPARPREDONLY+N)) = UTL_GETVAL(WTN,M,M)
              ! ENSURE OFF-DIAGONALS IN WTN ARE HONORED: CHECK PREVIOUS ADDITIONS IN THIS GROUP
              DO I=1,TOTNEW
                IF (NINDEX(I).NE.0.AND.I.NE.N) THEN
                  IF(UTL_GETPOS(WTN,I,M).NE.0) &
                    WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+NINDEX(I),NOBS+MPR+NPARPREDONLY+N)) = &
                      UTL_GETVAL(WTN,I,M)
                  IF(UTL_GETPOS(WTN,M,I).NE.0) &
                    WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+N,NOBS+MPR+NPARPREDONLY+NINDEX(I))) = &
                      UTL_GETVAL(WTN,M,I)
                END IF
              END DO
              TEMPNAME(NOBS+MPR+NPARPREDONLY+N)=TNAME(M)
            END IF
          END DO
        END DO
        IF(IADD.NE.numobs(iter))THEN
          LINE='ERROR: PROBLEM ENCOUNTERED ADDING NEW OBSERVATIONS - CHECK INPUTS (OPRPPR_UPDATEMATS)'
          CALL UTL_STOP(LINE)
        END IF
      ELSEIF (RUNFLAG.EQ.3) THEN !ITER IS THE OBSERVATION WE ARE ADDING
        NNEW=1
        ! ADD SENSITIVITIES INTO XSWPLOC
        DO I=1,NPERD
          XSWPLOC(I,NOBS+MPR+NPARPREDONLY+1) = XOBN(I,ITER)
        END DO
        ! ADD WEIGHT INTO WTMALL
        IF(NODEWT) WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+1,NOBS+MPR+NPARPREDONLY+1)) = &
                   UTL_GETVAL(WTN,ITER,ITER)
        IF(.NOT.NODEWT) WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+1,NOBS+MPR+NPARPREDONLY+1)) = 1.0D0
        TEMPNAME(NOBS+MPR+NPARPREDONLY+1)=TNAME(ITER)  !TNAME WAS BUILT IN ROUTINE READGSF
      ELSEIF (RUNFLAG.EQ.11) THEN
        NNEW=1
        DO I=1,NPERD
          XSWPLOC(I,NOBS+MPR+NPARPREDONLY+1) = 0.0D0
          IF(I.EQ.PARIND(ITER,1)) XSWPLOC(I,NOBS+MPR+NPARPREDONLY+1)=1.0D0
        END DO
        WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+1,NOBS+MPR+NPARPREDONLY+1)) = PRIORWT(1,PARIND(ITER,1))
        TEMPNAME(NOBS+MPR+NPARPREDONLY+1)=PARNAM(PARIND(ITER,1))
      ELSEIF (RUNFLAG.EQ.12) THEN
        NNEW=NPPERG
        DO N=1,NPPERG
          DO I=1,NPERD
            XSWPLOC(I,NOBS+MPR+NPARPREDONLY+N) = 0.0D0
          END DO
          IF(.NOT.FC.AND.N.EQ.1) XSWPLOC(NG,NOBS+MPR+NPARPREDONLY+N)=1.0D0
          IF(FC) XSWPLOC(PARIND(NG,N),NOBS+MPR+NPARPREDONLY+N)=1.0D0
        END DO
        DO N=1,NPPERG
          IF(.NOT.FC.AND.N.EQ.1) WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+N,NOBS+MPR+NPARPREDONLY+N)) = &
              PRIORWT(1,NG)
          IF(.NOT.FC) TEMPNAME(NOBS+MPR+NPARPREDONLY+N)=PARNAM(NG)
          IF(FC) WTMALL%DVAL(UTL_GETPOS(WTMALL,NOBS+MPR+NPARPREDONLY+N,NOBS+MPR+NPARPREDONLY+N)) = &
              PRIORWT(1,PARIND(NG,N))
          IF(FC) TEMPNAME(NOBS+MPR+NPARPREDONLY+N)=PARNAM(PARIND(NG,N))
        END DO
      END IF
      !
      ! CHECK THE WEIGHT MATRIX IS SYMMETRIC: IF NOT, SQUARE BY UPPER TRIANGLE, REPORT MESSAGE, CONTINUE
      ! (ALTERNATIVE IS TO FORM (W+WT)/2)
	  IF (IVERB.GE.5) THEN
        NOTSYM=.FALSE.
        DO M=1,NOBS+MPR+NPARPREDONLY+MAXNEW
          DO N=M,NOBS+MPR+NPARPREDONLY+MAXNEW
            IF(UTL_GETPOS(WTMALL,M,N).NE.0) THEN
              IF(UTL_GETVAL(WTMALL,M,N).NE.UTL_GETVAL(WTMALL,N,M)) THEN
                WTMALL%DVAL(UTL_GETPOS(WTMALL,N,M))=WTMALL%DVAL(UTL_GETPOS(WTMALL,M,N))
                NOTSYM=.TRUE.
              END IF
            END IF
          END DO
        END DO
	    IF (NOTSYM)WRITE(IOUT,10)
	  END IF
      IF (IVERB.EQ.3.AND.RUNFLAG.LT.11) CALL UTL_WRITECDMATRIX(WTMALL,0,IOUT,.FALSE.,TEMPNAME,TEMPNAME)
      IF (IVERB.EQ.3.AND.RUNFLAG.GE.11.AND.CONVERGED) CALL UTL_WRITECDMATRIX(WTMALL,0,IOUT,.FALSE.,TEMPNAME,TEMPNAME)
      IF (IVERB.GE.5) THEN
        IF(RUNFLAG.LT.11.OR.(RUNFLAG.GE.11.AND.CONVERGED))THEN
          WRITE(IOUT,20) ITER
          CALL OPRPPR_WRITEMATRIX(IOUT,MAXOB,NPERD,TEMPNAME,PARNAM,XSWPLOC)
          CALL UTL_WRITECDMATRIX(WTMALL,1,IOUT,.FALSE.,TEMPNAME,TEMPNAME)
        END IF
      END IF
      !
      RETURN !OKAY
      END SUBROUTINE OPRPPR_UPDATEMATS

! --------------------------------------------

      SUBROUTINE OPRPPR_GETWTPRIOR(PARNAM,PARV,CMDI,IVC,PRIORWT,IIPAR,ITER)
      ! IDENTIFY WEIGHT REQUIRED ON PRIOR TO ACHIEVE DESIRED REDUCTION IN PARAMETER STDEV
      USE UTILITIES, ONLY:             UTL_STOP
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                       :: IVC,IIPAR,ITER
      DOUBLE PRECISION              :: PARV(NPERD,0:IVC),CMDI(NPERD),PRIORWT(3,NPERD),PVB1,PVB2,PVB3
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD)
      SAVE  !PVB1,PVB2,PVB3
      ! PRIORWT(1,N) = NEW PRIOR WEIGHT ESTIMATE      : PVB1 = CURRENT RATIO
      ! PRIORWT(2,N) = CURRENT PRIOR WEIGHT ESTIMATE  : PVB2 = PREVIOUS RATIO
      ! PRIORWT(3,N) = BEST PRIOR WEIGHT ESTIMATE     : PVB3 = BEST RATIO
      ! PARV(IIPAR,1)= CURRENT PARAMETER VARIANCE WHILE FC=.FALSE. (FINAL WHEN FC=.TRUE.)
      IF(NITER.GT.MAXITER)CALL UTL_STOP('ERROR SOLVING FOR PRIOR WEIGHT: MAXITER EXCEEDED - STOP (OPRPPR_GETWTPRIOR)')
      IF(INIT)THEN
        PRIORWT(1,IIPAR)=(PERCENTREDUC/100.0D0)*CMDI(IIPAR)/VAR
        PVB1=1D+50
        PVB2=1D+50
        PVB3=1D+50
        INIT=.FALSE.
        RETURN
      END IF
      PVB2=PVB1                                                          !STORE PREVIOUS RATIO
      PRIORWT(2,IIPAR)=PRIORWT(1,IIPAR)                                  !STORE PREVIOUS WEIGHT
      PVB1=(SQRT(PARV(IIPAR,0))-SQRT(PARV(IIPAR,ITER)))/SQRT(PARV(IIPAR,0)) !STDEV REDUCTION
      IF(ABS(PVB1-PERCENTREDUC/100.0D0).EQ.ABS(PVB3-PERCENTREDUC/100.0D0)) &
        CALL UTL_STOP('ERROR ENCOUNTERED SOLVING FOR PRIOR WEIGHT - STOP (OPRPPR_GETWTPRIOR)')
      IF(ABS(PVB1-PERCENTREDUC/100.0D0).LT.ABS(PVB3-PERCENTREDUC/100.0D0))THEN
        PVB3=PVB1
        PRIORWT(3,IIPAR)=PRIORWT(1,IIPAR)
        PRIORWT(1,IIPAR)=PRIORWT(3,IIPAR)*ABS(PERCENTREDUC/100.0D0/PVB1)
        IF(ABS(PVB3-PERCENTREDUC/100.0D0).LE.TOLERANCE) CONVERGED=.TRUE.
      END IF
      RETURN !OKAY
      END SUBROUTINE OPRPPR_GETWTPRIOR

! --------------------------------------------

	  SUBROUTINE OPRPPR_CALC(MAXOB,PARNAM,PREDNAME,XSWP,ZPRE,WTMALL,PVAR,PARV,PARCORR,ITER,IVC,CMDI)
      ! PERFORMS THE Z(INV(XTwX)s)Zt CALCULATIONS: RECORDS PARAMETER AND PREDICTION VARIANCES
      USE GLOBAL_DATA, ONLY:     IVERB, MAX_STRING_LEN,LENDNAM
      USE DATATYPES
      USE UTILITIES, ONLY:       UTL_STOP,UTL_MATMUL,UTL_WRITECDMATRIX,UTL_SVD,UTL_ARR2CDMATRIX,ASSIGNMENT(=)
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                 :: MAXOB,I,J,K,ITER,IVC,N,IFAIL
      CHARACTER(LEN=LENPNAM)  :: PARNAM(NPERD)
      CHARACTER(LEN=LENDNAM)  :: PREDNAME(NPRED)
      DOUBLE PRECISION        :: ALPHA,BETA,CMDI(NPERD),ZPRE(NPERD,NPRED),XSWP(NPERD,MAXOB)
      DOUBLE PRECISION        :: PARV(NPERD,0:IVC),PVAR(NPRED,0:IVC) !,ZV(NPRED,NPRED)
      REAL(KIND=4)            :: PARCORR(0:IVC,NPERD,NPERD)
      TYPE (CDMATRIX)         :: WTMALL,A,AS
10    FORMAT(/,1X,'PRINTING ',A,' FOR ITERATION ',I5)
      ! INITIALIZE
      XTW  = 0.0D0
      CMAT = 0.0D0
      D    = 0.0D0
      AINV = 0.0D0
      ZCP  = 0.0D0
      ZV   = 0.0D0
      CMDI = 0.0D0
      CALL TYP_NULL(A)
      CALL TYP_NULL(AS)
      ! MAKE XtW
      XTW =  UTL_MATMUL(NPERD,MAXOB,XSWP,WTMALL)                   !XtW
      ! MAKE XtWX
      CMAT = MATMUL(XTW,TRANSPOSE(XSWP))                           !XtWX
      DO I=1,NPERD
        CMDI(I)=CMAT(I,I)
      END DO
      ! IF IVERB.GE.3 ECHO XtQX
      IF (IVERB.GE.3) THEN
        WRITE(IOUT,10) 'CALCULATED XtQX MATRIX',ITER
        CALL OPRPPR_WRITEMATRIX(IOUT,NPERD,NPERD,PARNAM,PARNAM,CMAT)    !USES NPPREC
      END IF
      ! STORE CMAT IN CDMATRIX STRUCTURE A
      CALL UTL_ARR2CDMATRIX(NPERD,NPERD,CMAT,A,0,'A MATRIX')
      IF (IVERB.GE.3) THEN
        WRITE(IOUT,10) 'CDMATRIX FORM OF XtQX',ITER
        IF (IVERB.GE.3) CALL UTL_WRITECDMATRIX(A,1,IOUT,.FALSE.,PARNAM,PARNAM)
      END IF
      ! INVERT USING SVD, RETURN INVERTED A AND SQRT INVERTED (AS)
      A%ARRAYNAME='A MATRIX'
      AS%ARRAYNAME='SQRTA MATRIX'
      CALL UTL_SVD(IFAIL,A,AS,DTLA)
      IF(IFAIL.NE.0) CALL UTL_STOP('ERROR ENCOUNTERED INVERTING "A" MATRIX (OPRPPR_CALC)')
      IF (IVERB.GE.3) THEN
        WRITE(IOUT,10) 'INVERTED A MATRIX IN CDMATRIX FORM',ITER
        IF (IVERB.GE.3) CALL UTL_WRITECDMATRIX(A,1,IOUT,.FALSE.,PARNAM,PARNAM)
      END IF
      ! MAKE USE OF USE "ASSIGNMENT (=)" OPERATOR FROM UTILITIES
      AINV = A
      CALL TYP_DEALLOC(A)
      CALL TYP_DEALLOC(AS)
      ! MULTIPLY BY REGRESSION ERROR VARIANCE. STORE VARIANCES (DIAGONALS) 0 IS BASE CASE
      AINV=AINV*VAR
      DO N=1,NPERD
        PARV(N,ITER)=AINV(N,N)
      END DO
      ! MAKE PREDICTION CALCS
      ZCP = TRANSPOSE(MATMUL(TRANSPOSE(ZPRE),AINV)) !ZC(p)
      ZV  = MATMUL(TRANSPOSE(ZCP),ZPRE)             !ZC(p)*Zt
      IF (IVERB.GE.3.AND.CONVERGED) THEN
        WRITE(IOUT,10) 'PREDICTION COVARIANCE MATRIX',ITER
        IF (IVERB.GE.3) CALL OPRPPR_WRITEMATRIX(IOUT,NPRED,NPRED,PREDNAME,PREDNAME,ZV)   !USES NPPREC
      END IF
      ! STORE PREDICTION VARIANCES - DIAGONALS ONLY: 0 IS BASE CASE
      DO N=1,NPRED
         PVAR(N,ITER)=ZV(N,N)
      END DO
      ! CONVERT COVARIANCE MATRIX TO CORRELATION MATRIX (RE-USE CMAT)
      CMAT = 0.0D0
      DO N = 1,NPERD
        DO K = 1,NPERD
          CMAT(N,K) = AINV(N,K)/(DSQRT(AINV(N,N))*DSQRT(AINV(K,K)))
        END DO
      END DO
      ! IF IVERB.GE.3 ECHO PARAMETER COVARIANCE AND CORRELATION MATRICES
      IF (IVERB.GE.3.AND.CONVERGED) THEN
        WRITE(IOUT,10) 'PARAMETER COVARIANCE MATRIX',ITER
        CALL OPRPPR_WRITEMATRIX(IOUT,NPERD,NPERD,PARNAM,PARNAM,AINV)    !USES NPPREC
        WRITE(IOUT,10) 'PARAMETER CORRELATION MATRIX',ITER
        CALL OPRPPR_WRITEMATRIX(IOUT,NPERD,NPERD,PARNAM,PARNAM,CMAT)    !USES NPPREC
      END IF
      ! STORE ALL CORRELATIONS (THIS COULD GET LARGE)
      DO N=1,NPERD
        DO K=1,NPERD
          PARCORR(ITER,K,N)=REAL(CMAT(K,N))
        END DO
      END DO
      !
      RETURN !OKAY
      END SUBROUTINE OPRPPR_CALC

! --------------------------------------------

      SUBROUTINE OPRPPR_NAMECHECK(NUMGPS,TNAME,TOTNEW,OBSNAME,PARNAM,IVC,PARIND,OPRNAME)
      ! PERFORMS VARIETY OF CHECKS ON OBSERVATION NAMES:
      ! FOR ANY CASE CHECK NAMES LISTED IN MAIN INPUT INPUT FILE ARE UNIQUE
      !   IF(RUNFLAG.LE.0) CHECK ALL OF OPRNAME EXIST IN OBSNAME
      !   IF(RUNFLAG.EQ.1 OR 2) CHECK NONE OF OPRNAME EXIST IN OBSNAME
      !   IF(RUNFLAG.EQ.1 OR 2) CHECK NAMES IN MAIN INPUT FILE ARE LISTED IN NEW _SU FILE
      !   IF(RUNFLAG.EQ.11) CHECK NAMES IN MAIN INPUT FILE ARE LISTED IN PARAMETER NAMES
      !   IF(RUNFLAG.EQ.12) NAMES WERE DETERMINED IN SUBROUTINE PPRGRPS AND SHOULD BE OKAY
      USE GLOBAL_DATA, ONLY:           IVERB, MAX_STRING_LEN,LENDNAM
      USE UTILITIES, ONLY:             UTL_STOP,UTL_CASE
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                            :: IVC,NUMGPS,N,M,K,TOTNEW,ICHK,NN,MM,PARIND(IVC,NPPERG)
      CHARACTER(LEN=LENDNAM)             :: TNAME(TOTNEW),TEMPNAM,OBSNAME(NDINC),OPRNAME(NGC,NGM)
      CHARACTER(LEN=LENPNAM)             :: PARNAM(NPERD)
      CHARACTER(LEN=MAX_STRING_LEN)      :: LINE
      ! FOR ANY CASE CHECK NAMES LISTED IN OPR INPUT FILE ARE UNIQUE
      DO N=1,NUMGPS
        DO M=1,NUMOBS(N)
          ICHK=0
          TEMPNAM=ADJUSTL(OPRNAME(N,M))
          DO NN=1,NUMGPS
            DO MM=1,NUMOBS(NN)
              IF(TRIM(ADJUSTL(OPRNAME(NN,MM))).EQ.TEMPNAM) ICHK=ICHK+1
            END DO
          END DO
          IF (ICHK.GT.1) THEN
            LINE=trim(adjustl(OPRNAME(N,M)))//' APPEARS MORE THAN ONCE IN MAIN INPUT FILE - STOP (OPRPPR_NAMECHECK)'
            CALL UTL_STOP(trim(adjustl(LINE)))
          END IF
        END DO
      END DO
      ! CHECK ALL OF OPRNAME EXIST IN OBSNAME IF OMITTING *OR* NONE OF OPRNAME EXIST IN OBSNAME IF ADDING
      DO N=1,NUMGPS
        DO M=1,NUMOBS(N)
          ICHK=0
          DO K=1,NDINC
            IF(TRIM(ADJUSTL(OPRNAME(N,M))).EQ.TRIM(ADJUSTL(OBSNAME(K)))) THEN
              IF(RUNFLAG.EQ.1.OR.RUNFLAG.EQ.2)THEN
                LINE=trim(adjustl(OPRNAME(N,M)))//' APPEARS IN BOTH "OBS" NAMES AND "ADD" NAMES - STOP (OPRPPR_NAMECHECK)'
                CALL UTL_STOP(trim(adjustl(LINE)))
              END IF
              ICHK = 1
            END IF
          END DO
          IF(RUNFLAG.LT.0.AND.ICHK.LT.1) THEN
            LINE=trim(adjustl(OPRNAME(N,M)))//' APPEARS IN "OMIT" NAMES BUT NOT IN "OBS" NAMES - STOP (OPRPPR_NAMECHECK)'
            CALL UTL_STOP(trim(adjustl(LINE)))
          END IF
        END DO
      END DO
      ! CHECK NAMES IN MAIN INPUT FILE FILE ARE LISTED IN NEW _SU FILE
      IF (RUNFLAG.EQ.1.OR.RUNFLAG.EQ.2) THEN
        DO N=1,NUMGPS
          DO M=1,NUMOBS(N)
            ICHK=0
            DO K=1,TOTNEW
              IF(TRIM(ADJUSTL(OPRNAME(N,M))).EQ.TRIM(ADJUSTL(TNAME(K)))) ICHK=1
            END DO
            IF(ICHK.EQ.0) THEN
              LINE=TRIM(ADJUSTL(OPRNAME(N,M)))//' APPEARS IN "ADD" NAMES BUT NOT IN NEW "_SU" NAMES - STOP (OPRPPR_NAMECHECK)'
              CALL UTL_STOP(TRIM(ADJUSTL(LINE)))
            END IF
          END DO
        END DO
      END IF
      ! CHECK NAMES IN MAIN INPUT FILE FILE ARE LISTED AS PARAMETERS IN THE EXISTING _SU FILE
      IF (RUNFLAG.EQ.11) THEN
        DO M=1,NUMOBS(1)
          ICHK=0
          DO K=1,NPERD
            IF(TRIM(ADJUSTL(OPRNAME(1,M))).EQ.TRIM(ADJUSTL(PARNAM(K)))) THEN
              ICHK=1
              PARIND(M,1)=K
            END IF
          END DO
          IF(ICHK.EQ.0) THEN
            LINE=trim(adjustl(OPRNAME(1,M)))// &
              ' APPEARS IN MAIN INPUT FILE BUT IS NOT LISTED IN "_SU" FILE - STOP (OPRPPR_NAMECHECK)'
            CALL UTL_STOP(trim(adjustl(LINE)))
          END IF
        END DO
      END IF
	RETURN !OKAY
      END SUBROUTINE OPRPPR_NAMECHECK

! --------------------------------------------

      SUBROUTINE OPRPPR_WRITE(PVAR,PARV,IVC,PARNAM,PREDNAME,NTIMES,PARCORR, &
                              NCOL,NROW,NLAY,OPRNAME,GRPNAME,I_PREDDAT,I_PREDGRP,PGRPNAME)
      ! WRITES SUMMARIES OF THE ANALYSES
      ! IVC = N0. OF (Y(INV(XtQX))Yt) CALCULATIONS MADE NOT INC. BASE CASE
      USE GLOBAL_DATA, ONLY:           IVERB,LENDNAM
      USE UTILITIES, ONLY:             UTL_STOP
      USE OPR_PPR_VAR
      IMPLICIT NONE
      INTEGER                       :: IVC,IERR,N,M,FLEN,NCOL,NROW,NLAY,NTIMES, &   !!!KSTP(NTIMES),KPER(NTIMES),
                                       I_PREDDAT,I_PREDGRP,MM,NN
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD)
      CHARACTER(LEN=LENDNAM)        :: PREDNAME(NPRED),LOCNAME(IVC),OPRNAME(NGC,NGM),GRPNAME(NGC)
      CHARACTER(LEN=LENDNAM)        :: PGRPNAME(I_PREDGRP),PGRPNLOCAL(NPGRPUSE) ! PREDICTION GROUP NAMES
      CHARACTER(LEN=100)            :: OPRFNAM,OPRABSFNAM,OPAFNAM,OPAABSFNAM,OPRNODFNAM,OPRNODABSFNAM, &
                                       OPANODFNAM,OPANODABSFNAM
      INTEGER                       :: OPRUNIT,OPAUNIT,BINUNIT
      DOUBLE PRECISION              :: PARV(NPERD,0:IVC),PVAR(NPRED,0:IVC)
      REAL(KIND=4)                  :: PARCORR(0:IVC,NPERD,NPERD)
      REAL, ALLOCATABLE, DIMENSION(:,:)  :: PVARS,PARVS,PVARSGRP
      REAL, ALLOCATABLE, DIMENSION(:)    :: PVARSUM
      LOGICAL ::  ALLOCATEERROR
      ! INITIALIZE FILE NAMES AND
      FLEN=INDEX(AOPROUT,'.')
      IF (ABS(RUNFLAG).LE.2) OPRFNAM=AOPROUT(1:FLEN-1)//'._OPR'
      IF (ABS(RUNFLAG).LE.2) OPRABSFNAM=AOPROUT(1:FLEN-1)//'._OPR_ABSCHG'
      IF (ABS(RUNFLAG).LE.2) OPAFNAM=AOPROUT(1:FLEN-1)//'._OPA'
      IF (ABS(RUNFLAG).LE.2) OPAABSFNAM=AOPROUT(1:FLEN-1)//'._OPA_ABSCHG'
      IF (ABS(RUNFLAG).EQ.3) OPRNODFNAM=AOPROUT(1:FLEN-1)//'._OPRNOD'
      IF (ABS(RUNFLAG).EQ.3) OPRNODABSFNAM=AOPROUT(1:FLEN-1)//'._OPRNOD_ABSCHG'
      IF (ABS(RUNFLAG).EQ.3) OPANODFNAM=AOPROUT(1:FLEN-1)//'._OPANOD'
      IF (ABS(RUNFLAG).EQ.3) OPANODABSFNAM=AOPROUT(1:FLEN-1)//'._OPANOD_ABSCHG'
      IF (RUNFLAG.GE.11)     OPRFNAM=AOPROUT(1:FLEN-1)//'._PPR'
      IF (RUNFLAG.GE.11)     OPRABSFNAM=AOPROUT(1:FLEN-1)//'._PPR_ABSCHG'
      IF (RUNFLAG.GE.11)     OPAFNAM=AOPROUT(1:FLEN-1)//'._PPA'
      IF (RUNFLAG.GE.11)     OPAABSFNAM=AOPROUT(1:FLEN-1)//'._PPA_ABSCHG'
      OPRUNIT=84
      OPAUNIT=85
      BINUNIT=87
      ! FORMATS
19    FORMAT(/,1x,24('='),/,1x,a,/,1x,24('='))
20    FORMAT(/,1x,46('-'),/,1x,a,/,1x,46('-'))
21    FORMAT(/,1x,44('-'),/,1x,a,/,1x,44('-'))
22    FORMAT(/,1x,45('-'),/,1x,a,/,1x,45('-'))
30    FORMAT(/,1X,'FORMING AND WRITING OPR STATISTIC FILES ....',/)
40    FORMAT(/,1X,'FORMING AND WRITING PPR STATISTIC FILES ....',/)
      WRITE(IOUT,19) 'OPR-PPR ANALYSIS SUMMARY'
      IF(ABS(RUNFLAG).LE.3)WRITE(IOUT,30)
      IF(ABS(RUNFLAG).GE.11)WRITE(IOUT,40)
      ALLOCATE(PVARS(NPRED,IVC),PARVS(NPERD,IVC),PVARSUM(IVC),STAT=IERR)
      IF (ALLOCATEERROR(IOUT,IERR,'STAT ARRAYS')) CALL UTL_STOP('(OPRPPR_WRITE)')
      IF (PREDGROUPS.EQ.'YES') ALLOCATE(PVARSGRP(NPGRPUSE,IVC),STAT=IERR)
      IF (ALLOCATEERROR(IOUT,IERR,'PVARSGRP')) CALL UTL_STOP('(OPRPPR_WRITE)')
      ! LOAD LOCAL NAME ARRAY FOR WRITE OUT OF SIMPLE ARRAYS (NOT NODES)
      DO N=1,IVC
        IF (ABS(RUNFLAG).EQ.1.OR.RUNFLAG.EQ.11) LOCNAME(N)=OPRNAME(1,N)
        IF (ABS(RUNFLAG).EQ.2.OR.RUNFLAG.EQ.12) LOCNAME(N)=GRPNAME(N)
      END DO
      NN=0
      IF(PREDGROUPS.EQ.'YES') THEN
        DO N=1,I_PREDGRP
          IF(USEFLAGP(N))THEN
            NN=NN+1
            PGRPNLOCAL(NN)=PGRPNAME(N)
            !WRITE(*,*) PGRPNAME(N),NN,PGRPNLOCAL(NN)
          END IF
        END DO
      END IF
      ! SQRT VARIANCES TO STDEVS FOR ALL REPORTING
      PARV = DSQRT(PARV)   !PARAMETERS
      PVAR = DSQRT(PVAR)   !PREDICTIONS
      ! *********************************************
      ! OPR_ABSCHG STATISTIC
      ! ACTUAL CHANGE IN UNCERT STDEV= {S(IVC)-S(BASE)}
      ! *********************************************
      PVARS=0.0
      DO N=1,NPRED
        DO M=1,IVC
          PVARS(N,M)= REAL((PVAR(N,M) - PVAR(N,0)))
        END DO
      END DO
      ! SUMMARIZE OPR_ABSCHG STATISTIC RESULTS BY PREGROUPS?
      IF (PREDGROUPS.EQ.'YES') THEN
        PVARSGRP=0.0
        DO M=1,IVC
          NN=0
          DO N=1,I_PREDGRP
            IF(USEFLAGP(N))THEN
              NN=NN+1
              DO MM=1,I_PREDDAT
                IF(PGFLAG(N,MM).GT.0)THEN
                  PVARSGRP(NN,M)=PVARSGRP(NN,M)+PVARS(MM,M)
                END IF
              END DO
              PVARSGRP(NN,M)=PVARSGRP(NN,M)/REAL(NUMPRED(N))
            END IF
          END DO
        END DO
      END IF
      ! REPORT THESE VALUES
      IF(RUNFLAG.EQ.3) THEN ! WRITE TO BINARY OR ASCII FILE
        IF (PREDGROUPS.EQ.'NO') THEN
          CALL OPRPPR_WRITENOD(NPRED,IVC,NLAY,NROW,NCOL,NTIMES,PVARS,OPRNODABSFNAM,BINUNIT,PREDNAME)
        ELSE
          CALL OPRPPR_WRITENOD(NPGRPUSE,IVC,NLAY,NROW,NCOL,NTIMES,PVARSGRP,OPRNODABSFNAM,BINUNIT,PGRPNLOCAL)
        END IF
      ELSE ! TABLE FORMATS TO MAIN OUTPUT PLUS _OPR_ABDCHG OR _PPR_ABSCHG
        IF (PREDGROUPS.EQ.'NO') THEN
          WRITE(IOUT,20) 'ABSOLUTE CHANGE: PREDICTION STANDARD DEVIATIONS (OPR_ABSCHG STATISTIC)'
          CALL OPRPPR_WRITEMATRIX(IOUT,IVC,NPRED,LOCNAME,PREDNAME,DBLE(PVARS))          !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,3,OPRABSFNAM,IOUT)
          CALL OPRPPR_WRITEMATRIX(OPRUNIT,IVC,NPRED,LOCNAME,PREDNAME,DBLE(PVARS))       !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,2,OPRABSFNAM,IOUT)
        ELSE
          WRITE(IOUT,21) 'PREDICTION GROUP SUMMARY (OPR_ABSCHG AVERAGED BY GROUP)'
          CALL OPRPPR_WRITEMATRIX(IOUT,IVC,NPGRPUSE,LOCNAME,PGRPNLOCAL,DBLE(PVARSGRP))     !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,3,OPRABSFNAM,IOUT)
          CALL OPRPPR_WRITEMATRIX(OPRUNIT,IVC,NPGRPUSE,LOCNAME,PGRPNLOCAL,DBLE(PVARSGRP))  !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,2,OPRABSFNAM,IOUT)
        END IF
      END IF
      ! *********************************************
      ! OPA_ABSCHG STATISTIC
      ! ACTUAL CHANGE IN PARAM STDEV (SAME FORM AS OPR_ABSCHG)
      ! *********************************************
      PARVS=0.0
      DO N=1,NPERD
        DO M=1,IVC
          PARVS(N,M)= REAL((PARV(N,M) - PARV(N,0)))
        END DO
      END DO
      ! REPORT THESE VALUES
      IF(RUNFLAG.EQ.3)THEN ! WRITE TO BINARY OR ASCII FILE
        CALL OPRPPR_WRITENOD(NPERD,IVC,NLAY,NROW,NCOL,NTIMES,PARVS,OPANODABSFNAM,BINUNIT,PARNAM)
      ELSE ! TABLE FORMATS TO MAIN OUTPUT PLUS _OPA OR _PPA FILE
        WRITE(IOUT,20) 'ABSOLUTE CHANGE: PARAMETER STANDARD DEVIATIONS'
        CALL OPRPPR_WRITEMATRIX(IOUT,IVC,NPERD,LOCNAME,PARNAM,DBLE(PARVS))     !USES NPPREC
        CALL OPRPPR_OPENFILE(OPAUNIT,3,OPAABSFNAM,IOUT)
        CALL OPRPPR_WRITEMATRIX(OPAUNIT,IVC,NPERD,LOCNAME,PARNAM,DBLE(PARVS))  !USES NPPREC
        CALL OPRPPR_OPENFILE(OPAUNIT,2,OPAABSFNAM,IOUT)
      END IF
      ! *********************************************
      ! OPR/PPR STATISTIC
      ! PERC. INC/DEC UNCERT STDEV = {ABS([1.0-(S(IVC)/S(BASE))]x100)}
      ! *********************************************
      PVARS=0.0
      PVARSUM=0.0
      DO N=1,NPRED
        DO M=1,IVC
		PVARS(N,M)= ABS(100.0 * REAL(1.0D0-(PVAR(N,M) / PVAR(N,0))))
		IF(PVARS(N,M).LE.OPRPPR_PRECISION) PVARS(N,M)=0.0
          ! LOAD SUMMARY INTO VECTOR BY SUMMATION (ADDING) STATISTIC
          PVARSUM(M)=PVARS(N,M)+PVARSUM(M)
        END DO
      END DO
      ! SUMMARIZE OPR STATISTIC BY PREGROUPS?
      IF (PREDGROUPS.EQ.'YES') THEN
        PVARSGRP=0.0
        DO M=1,IVC
          NN=0
          DO N=1,I_PREDGRP
            IF(USEFLAGP(N))THEN
              NN=NN+1
              DO MM=1,I_PREDDAT
                IF(PGFLAG(N,MM).GT.0)THEN
                  PVARSGRP(NN,M)=PVARSGRP(NN,M)+PVARS(MM,M)
                END IF
              END DO
              PVARSGRP(NN,M)=PVARSGRP(NN,M)/REAL(NUMPRED(N))
            END IF
          END DO
        END DO
      END IF
      ! REPORT THE OPR STATISTIC RESULTS
      IF (ABS(RUNFLAG).EQ.3) THEN
        IF (PREDGROUPS.EQ.'NO') THEN
          CALL OPRPPR_WRITENOD(NPRED,IVC,NLAY,NROW,NCOL,NTIMES,PVARS,OPRNODFNAM,BINUNIT,PREDNAME)
        ELSE
          CALL OPRPPR_WRITENOD(NPGRPUSE,IVC,NLAY,NROW,NCOL,NTIMES,PVARSGRP,OPRNODFNAM,BINUNIT,PGRPNLOCAL)
        END IF
      ELSE ! STANDARD MF2K TABLE FORMATS TO MAIN OUTPUT FILE
        IF (PREDGROUPS.EQ.'NO') THEN
          WRITE(IOUT,20) 'PERCENT CHANGE: PREDICTION STANDARD DEVIATIONS (OPR/PRR STATISTIC)'
          CALL OPRPPR_WRITEMATRIX(IOUT,IVC,NPRED,LOCNAME,PREDNAME,DBLE(PVARS))           !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,3,OPRFNAM,IOUT)
          CALL OPRPPR_WRITEMATRIX(OPRUNIT,IVC,NPRED,LOCNAME,PREDNAME,DBLE(PVARS))        !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,2,OPRFNAM,IOUT)
        ELSE
          WRITE(IOUT,21) 'PREDICTION GROUP SUMMARY (OPR/PPR STATISTICS AVERAGED BY GROUP)'
          CALL OPRPPR_WRITEMATRIX(IOUT,IVC,NPGRPUSE,LOCNAME,PGRPNLOCAL,DBLE(PVARSGRP))     !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,3,OPRFNAM,IOUT)
          CALL OPRPPR_WRITEMATRIX(OPRUNIT,IVC,NPGRPUSE,LOCNAME,PGRPNLOCAL,DBLE(PVARSGRP))  !USES NPPREC
          CALL OPRPPR_OPENFILE(OPRUNIT,2,OPRFNAM,IOUT)
        END IF
      END IF
      ! *********************************************
      ! OPA/PPA STATISTIC
      ! PERC. INC/DEC PARAMETER STDEV (SAME FORM)
      ! *********************************************
      PARVS=0.0
      DO N=1,NPERD
        DO M=1,IVC
          PARVS(N,M)= 100.0 * REAL((PARV(N,M) / PARV(N,0))-1.0D0)
        END DO
      END DO
      ! REPORT THESE VALUES
      IF(RUNFLAG.EQ.3)THEN ! WRITE TO BINARY OR ASCII FILE
        CALL OPRPPR_WRITENOD(NPERD,IVC,NLAY,NROW,NCOL,NTIMES,PARVS,OPANODFNAM,BINUNIT,PARNAM)
      ELSE ! TABLE FORMATS TO MAIN OUTPUT PLUS _OPA OR _PPA FILE
        WRITE(IOUT,22) 'PERCENT CHANGE: PARAMETER STANDARD DEVIATIONS'
        CALL OPRPPR_WRITEMATRIX(IOUT,IVC,NPERD,LOCNAME,PARNAM,DBLE(PARVS))         !USES NPPREC
        CALL OPRPPR_OPENFILE(OPAUNIT,3,OPAFNAM,IOUT)
        CALL OPRPPR_WRITEMATRIX(OPAUNIT,IVC,NPERD,LOCNAME,PARNAM,DBLE(PARVS))      !USES NPPREC
        CALL OPRPPR_OPENFILE(OPAUNIT,2,OPAFNAM,IOUT)
      END IF
      ! *********************************************
      ! OPC/PPC LIST
      ! CORRELATIONS GREATER THAN CORRELTHRESH
      ! *********************************************
      IF (ABS(RUNFLAG).NE.3) THEN
        !IF (OPCNODOPTION.NE.'NAMEDPAIR') WRITE(IOUT,22) ' CORRELATIONS GREATER THAN "CORRELTHRESH"'
        !IF (OPCNODOPTION.EQ.'NAMEDPAIR') WRITE(IOUT,22) ' CORRELATIONS FOR SPECIFIED "NAMEDPAIR" '
        WRITE(IOUT,22) 'CORRELATIONS GREATER THAN "CORRELTHRESH"'
        CALL OPRPPR_WRITECCH(PARCORR,PARNAM,IVC,LOCNAME)
      END IF
      IF (ABS(RUNFLAG).EQ.3) THEN
        CALL OPRPPR_WRITEOPCNOD(PARCORR,PARNAM,IVC,LOCNAME,NLAY,NROW,NCOL,NTIMES)
      END IF
      ! *********************************************
      ! SORTED SUMMARY TO MAIN OUTPUT FILE (NOT RUNFLAG=3)
      ! *********************************************
      ! SORT AND REPORT TOP AND BOTTOM STATISTICS IN THE PVAR ARRAY
      IF (ABS(RUNFLAG).NE.3.AND.IVC.GT.1) CALL OPRPPR_PVARSORT(IVC,PVARSUM,LOCNAME)
      !
      ! DEALLOCATE LOCALLY
      DEALLOCATE(PVARS,PARVS,PVARSUM,STAT=IERR)
      IF (ALLOCATED(PVARSGRP)) DEALLOCATE(PVARSGRP)
      RETURN !OKAY
      END SUBROUTINE OPRPPR_WRITE

! --------------------------------------------

      SUBROUTINE OPRPPR_WRITEOPCNOD(PARCORR,PARNAM,IVC,LOCNAME,NLAY,NROW,NCOL,NTIMES)
      USE GLOBAL_DATA, ONLY:           IVERB,LENDNAM
      USE OPR_PPR_VAR, ONLY:           IOUT,NPERD,LENPNAM,AOPROUT,FILEFORMAT,OPCNODOPTION,IPARAMPAIR, &
                                       KSTP,KPER,PERTIM,TOTIM,CORRELTHRESH
      USE UTILITIES, ONLY:             UTL_STOP,UTL_NUM2CHAR
      INTEGER                       :: IVC,N,K,M,OPCNODUNIT,OPCNODPARSUNIT,FLEN,IGRDT,IPNT,JCOL,IROW,KLAY,ILEN
      INTEGER                       :: NLAY,NCOL,NROW,NTIMES, NT !swm: defined NT
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD),PARAMPAIRMAX(NCOL,NROW),BLANK
      CHARACTER(LEN=LENDNAM)        :: LOCNAME(IVC)
      CHARACTER(LEN=100)            :: OPCNODFNAM,OPCNODPARSFNAM
      REAL(KIND=4)                  :: PARCORR(0:IVC,NPERD,NPERD)
      REAL(KIND=4)                  :: OPCNODARR(NCOL,NROW),CORRDIFF
      CHARACTER(LEN=3)              :: AITN,CLENPNAM
      CHARACTER(LEN=16)             :: AFMT,BFMT,TEXT
   10 FORMAT(1X,A20,4(1X,A12))
   20 FORMAT(1X,A20,2(1X,A12),2(1X,G12.5))
   25 FORMAT(/,1X,'WRITING RESULTS OF _OPCNOD CALCULATIONS TO ',A,' FORMAT FILE')
   30 FORMAT(/,1X,'WRITING _OPCNOD FILE ',A)
   40 FORMAT(/,1X,'WRITING _OPCNOD_PARS FILE ',A,' (ALWAYS ASCII)')
   50 FORMAT(/,1X,'NO _OPCNOD_PARS FILE WILL BE WRITTEN')
   60 FORMAT(1X,'TIMESTEP: ',I3,' STRESS PERIOD: ',I3,' LAYER: ',I3,' ARRAY TIME: ',A)
   70 FORMAT(1X,2(1X,I5),2(1X,F10.0),1X,A16,3(1X,I5))
      !
      FLEN=INDEX(AOPROUT,'.')
      OPCNODUNIT=88
      OPCNODPARSUNIT=89
      OPCNODFNAM=AOPROUT(1:FLEN-1)//'._OPCNOD'
      OPCNODPARSFNAM=AOPROUT(1:FLEN-1)//'._OPCNOD_PARS'
      ! REPORT MESSAGE
      IF(FILEFORMAT.EQ.'BINARY') WRITE(IOUT,25) TRIM(ADJUSTL(OPCNODFNAM))
      ! ESTABLISH FORMAT FOR ASCII
      AFMT=' '
      BFMT=' '
      CLENPNAM=' '
      WRITE(AITN,'(I3)') NCOL
      WRITE(CLENPNAM,'(I3)') LENPNAM
      AFMT='('//TRIM(ADJUSTL(AITN))//'(1X,G16.6))'
      BFMT='('//TRIM(ADJUSTL(AITN))//'(1X,A'//TRIM(ADJUSTL(CLENPNAM))//'))'
      WRITE(IOUT,30) TRIM(OPCNODFNAM)
      IF(FILEFORMAT.EQ.'BINARY') CALL OPRPPR_OPENFILE(OPCNODUNIT,4,OPCNODFNAM,IOUT)
      IF(FILEFORMAT.EQ.'ASCII') CALL OPRPPR_OPENFILE(OPCNODUNIT,3,OPCNODFNAM,IOUT)
      IF(FILEFORMAT.EQ.'TABLE') CALL OPRPPR_OPENFILE(OPCNODUNIT,3,OPCNODFNAM,IOUT)
      IF(OPCNODOPTION.EQ.'ALLPAIRMAX') THEN
        WRITE(IOUT,40) TRIM(OPCNODPARSFNAM)
        CALL OPRPPR_OPENFILE(OPCNODPARSUNIT,3,OPCNODPARSFNAM,IOUT)
      ELSE
        WRITE(IOUT,50)
      END IF
      OPCNODARR=0.0
      IGRDT=0      !COUNTER THAT JUMPS DOWN BY NUMBER OF TIMES * NUMBER OF CELLS
      DO NT=1,NTIMES
        IGRDT=IGRDT + ((NT-1)*NLAY*NCOL*NROW)
        DO KLAY=1,NLAY
          DO IROW=1,NROW
            DO JCOL=1,NCOL
              IPNT=IGRDT + (KLAY-1)*(NCOL*NROW) + (IROW-1)*NCOL + JCOL
              IF(OPCNODOPTION.EQ.'NAMEDPAIR') THEN
                !WRITE(*,*) PARCORR(IPNT,IPARAMPAIR(1),IPARAMPAIR(2))
                !WRITE(*,*) PARCORR(0,IPARAMPAIR(1),IPARAMPAIR(2))
                OPCNODARR(JCOL,IROW)=                          &
                   ((abs(PARCORR(IPNT,IPARAMPAIR(1),IPARAMPAIR(2))) &
                   -abs(PARCORR(0,IPARAMPAIR(1),IPARAMPAIR(2))))    &
                    / abs(PARCORR(0,IPARAMPAIR(1),IPARAMPAIR(2))))  &
                   * 100.                       !PERCENT CHANGE
                !WRITE(*,*) OPCNODARR(JCOL,IROW)
              ELSE
                DO N=1,NPERD
                  DO K=N,NPERD
                    IF(K.NE.N) THEN
					if(abs(PARCORR(0,K,N)).gt.abs(correlthresh)) then
                        CORRDIFF=((abs(PARCORR(IPNT,K,N))-abs(PARCORR(0,K,N)))/abs(PARCORR(0,K,N))) * 100.      !PERCENT CHANGE
					  !CORRDIFF=((abs(PARCORR(IPNT,K,N))-abs(PARCORR(0,K,N)))/abs(PARCORR(IPNT,K,N))) * 100.  !ALT PERCENT CHANGE
                        IF(ABS(CORRDIFF).GT.ABS(OPCNODARR(JCOL,IROW))) THEN
                          OPCNODARR(JCOL,IROW)=CORRDIFF
                          PARAMPAIRMAX(JCOL,IROW)='000000000000'
                          CALL UTL_NUM2CHAR(K,AITN,3)
                          ILEN=LEN(TRIM(AITN))
                          PARAMPAIRMAX(JCOL,IROW)(LENPNAM-ILEN+1:LENPNAM)=TRIM(ADJUSTL(AITN))
                          CALL UTL_NUM2CHAR(N,AITN,3)
                          ILEN=LEN(TRIM(AITN))
                          PARAMPAIRMAX(JCOL,IROW)(LENPNAM-ILEN-3+1:LENPNAM-3)=TRIM(ADJUSTL(AITN))
                        END IF
                      END IF
				  END IF
                  END DO
                END DO
              END IF
            END DO
          END DO
		OPCNODARR=abs(opcnodarr)
          WRITE(AITN,'(I3)') NT
          TEXT='                '
          ILEN=LEN(TRIM(AITN))
          TEXT(1:4+ILEN)='TIME'//TRIM(ADJUSTL(AITN))
          WRITE(IOUT,60) KSTP(NT),KPER(NT),KLAY,TRIM(ADJUSTL(TEXT))
          IF(FILEFORMAT.EQ.'BINARY') WRITE(OPCNODUNIT) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,KLAY
          IF(FILEFORMAT.EQ.'BINARY') WRITE(OPCNODUNIT) ((OPCNODARR(JCOL,IROW),JCOL=1,NCOL),IROW=1,NROW)
          IF(FILEFORMAT.EQ.'ASCII')  WRITE(OPCNODUNIT,70) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,KLAY
          IF(FILEFORMAT.EQ.'ASCII')  WRITE(OPCNODUNIT,AFMT) ((OPCNODARR(JCOL,IROW),JCOL=1,NCOL),IROW=1,NROW)
          IF(FILEFORMAT.EQ.'TABLE')  WRITE(OPCNODUNIT,70) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,KLAY
          IF(FILEFORMAT.EQ.'TABLE')  WRITE(OPCNODUNIT,AFMT) ((OPCNODARR(JCOL,IROW),JCOL=1,NCOL),IROW=1,NROW)
          IF(OPCNODOPTION.NE.'NAMEDPAIR') &
             WRITE(OPCNODPARSUNIT,70) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,KLAY
          IF(OPCNODOPTION.NE.'NAMEDPAIR') WRITE(OPCNODPARSUNIT,BFMT)((PARAMPAIRMAX(JCOL,IROW),JCOL=1,NCOL),IROW=1,NROW)
        END DO
      END DO
      ! CLOSE THE FILES
      CALL OPRPPR_OPENFILE(OPCNODUNIT,2,OPCNODFNAM,IOUT)
      IF(OPCNODOPTION.EQ.'ALLPAIRMAX') CALL OPRPPR_OPENFILE(OPCNODPARSUNIT,2,OPCNODPARSFNAM,IOUT)
      RETURN !OKAY
      END SUBROUTINE OPRPPR_WRITEOPCNOD

! --------------------------------------------

      SUBROUTINE OPRPPR_WRITECCH(PARCORR,PARNAM,IVC,LOCNAME)
      USE GLOBAL_DATA, ONLY:           IVERB,LENDNAM
      USE OPR_PPR_VAR, ONLY:           ICORRELTHRESH,CORRELTHRESH,IOUT,NPERD,LENPNAM,AOPROUT,RUNFLAG
      USE UTILITIES, ONLY:             UTL_STOP
      INTEGER                       :: IVC,N,K,M,OPCUNIT,FLEN
      CHARACTER(LEN=LENPNAM)        :: PARNAM(NPERD)
      CHARACTER(LEN=LENDNAM)        :: LOCNAME(IVC)
      CHARACTER(LEN=100)            :: OPCFNAM
      REAL(KIND=4)                  :: PARCORR(0:IVC,NPERD,NPERD)
   10 FORMAT(1X,A20,5(1X,A12))
   20 FORMAT(1X,A20,2(1X,A12),3(1X,G12.6))
   30 FORMAT(/,1X,'NO PARAMETER CORRELATIONS GREATER THAN "CORRELTHRESH"',F10.4,' TO REPORT')
   40 FORMAT(/,1X,I4,' PARAMETER CORRELATIONS GREATER THAN "CORRELTHRESH"',F10.4,' REPORTED')
!swm   50 FORMAT(1X,'ICORRELTHRESH = ',I)
   50 FORMAT(1X,'ICORRELTHRESH = ',I0)
      FLEN=INDEX(AOPROUT,'.')
      OPCUNIT=88
      IF (ABS(RUNFLAG).LE.2) OPCFNAM=AOPROUT(1:FLEN-1)//'._OPC'
      IF (RUNFLAG.GE.11)     OPCFNAM=AOPROUT(1:FLEN-1)//'._PPC'
      ! COUNT THE ENTRIES FOR THE FILE
      DO M=0,IVC
        DO N=1,NPERD
          DO K=N,NPERD
            IF(K.NE.N) THEN
              IF(M.EQ.0) THEN
                IF(ABS(PARCORR(M,K,N)).GE.ABS(CORRELTHRESH)) ICORRELTHRESH=ICORRELTHRESH+1
              ELSEIF(ABS(PARCORR(M,K,N)).GE.ABS(CORRELTHRESH)) THEN     !**ALT** .AND.ABS(PARCORR(0,K,N)).LT.ABS(CORRELTHRESH)) THEN
                ICORRELTHRESH=ICORRELTHRESH+1
              END IF
            END IF
          END DO
        END DO
      END DO
      IF(ICORRELTHRESH.EQ.0) WRITE(IOUT,30) CORRELTHRESH
      IF(ICORRELTHRESH.GT.0) THEN
        WRITE(IOUT,40) ICORRELTHRESH,CORRELTHRESH
        CALL OPRPPR_OPENFILE(OPCUNIT,3,OPCFNAM,IOUT)
        WRITE(OPCUNIT,50) ICORRELTHRESH
        WRITE(OPCUNIT,10) 'GRP/OBS/PAR          ','PARNAM      ','PARNAM      ', &
                          'BASECASE    ','CHANGED     ','PRECENT     '
        DO M=0,IVC
          DO N=1,NPERD
            DO K=N,NPERD
              !IF (OPCNODOPTION.NE.'NAMEDPAIR') THEN
                IF(K.NE.N) THEN
                  IF(M.EQ.0) THEN
                    IF(ABS(PARCORR(M,K,N)).GE.ABS(CORRELTHRESH))         &
                      WRITE(OPCUNIT,20) 'BASECASE            ',PARNAM(K),PARNAM(N), &
                                        PARCORR(0,K,N),PARCORR(M,K,N), &
                                        ((ABS(PARCORR(M,K,N))-ABS(PARCORR(0,K,N)))/ABS(PARCORR(0,K,N)))*100.
                  ELSEIF(ABS(PARCORR(M,K,N)).GE.ABS(CORRELTHRESH)) THEN !**ALT** .AND.ABS(PARCORR(0,K,N)).LT.ABS(CORRELTHRESH)) THEN
                    WRITE(OPCUNIT,20) LOCNAME(M),PARNAM(K),PARNAM(N), &
                                      PARCORR(0,K,N),PARCORR(M,K,N),  &
                                      ((ABS(PARCORR(M,K,N))-ABS(PARCORR(0,K,N)))/ABS(PARCORR(0,K,N)))*100.
                  END IF
                END IF
            END DO
          END DO
        END DO
        CALL OPRPPR_OPENFILE(OPCUNIT,2,OPCFNAM,IOUT)
      END IF
      RETURN !OKAY
      END SUBROUTINE OPRPPR_WRITECCH

! --------------------------------------------

      SUBROUTINE OPRPPR_WRITENOD(NPRED,IVC,NLAY,NROW,NCOL,NTIMES,PVARS,OPRNODFNAM,BINUNIT,PREDNAME)
      ! WRITE BINARY HDS FORMAT OUTPUT OF GRID-SENSITIVITY BASED OPR CALCULATIONS
      USE GLOBAL_DATA, ONLY:           IVERB,LENDNAM
      USE OPR_PPR_VAR, ONLY:           FILEFORMAT,IOUT,KSTP,KPER,TOTIM,PERTIM
      IMPLICIT NONE
      INTEGER                       :: IVC,IERR,BINUNIT,NROW,NCOL,NLAY,NTIMES,IGRDSEN,IGRDT,NPRED
      INTEGER                       :: NT,N,K,I,ILEN               !!!!KSTP(NTIMES),KPER(NTIMES),
      CHARACTER(LEN=*)              :: PREDNAME(NPRED)
      CHARACTER(LEN=100)            :: OPRNODFNAM
      CHARACTER(LEN=16)             :: TEXT,AFMT
      CHARACTER(LEN=3)              :: AITN
      REAL                          :: PVARS(NPRED,IVC)
20    FORMAT(/,1X,'WRITING RESULTS OF NODE CALCULATIONS TO BINARY HEAD-SAVE FORMAT FILE ',A)
30    FORMAT(1X,'TIMESTEP: ',I3,' STRESS PERIOD: ',I3,' LAYER: ',I3,' PREDICTION/GROUP: ',A)
40    FORMAT(1X,2(1X,I5),2(1X,F10.0),1X,A16,3(1X,I5))
50    FORMAT(1X,'WRITING RESULTS OF NODE CALCULATIONS TO ASCII FILE WITH FORMAT ',A)
      ! REPORT MESSAGE
      IF(FILEFORMAT.EQ.'BINARY') WRITE(IOUT,20) TRIM(ADJUSTL(OPRNODFNAM))
      ! ESTABLISH FORMAT FOR ASCII
      AFMT=' '
      WRITE(AITN,'(I3)') NCOL
      AFMT='('//TRIM(ADJUSTL(AITN))//'(1X,G16.6))'
      IF(FILEFORMAT.EQ.'ASCII'.OR.FILEFORMAT.EQ.'TABLE') WRITE(IOUT,50) AFMT
      ! START ROUTINE
      IF(FILEFORMAT.EQ.'BINARY') CALL OPRPPR_OPENFILE(BINUNIT,4,OPRNODFNAM,IOUT)
      IF(FILEFORMAT.EQ.'ASCII') CALL OPRPPR_OPENFILE(BINUNIT,3,OPRNODFNAM,IOUT)
      IF(FILEFORMAT.EQ.'TABLE') CALL OPRPPR_OPENFILE(BINUNIT,3,OPRNODFNAM,IOUT)
      IGRDT=0      !COUNTER THAT JUMPS DOWN BY NUMBER OF TIMES * NUMBER OF CELLS
      IGRDSEN=1    !COUNTER THAT STEPS THROUGH COLS, ROWS, LAYS
      DO NT=1,NTIMES
        IGRDT=IGRDT+((NT-1)*NLAY*NCOL*NROW)
        DO N=1,NPRED
          IGRDSEN=IGRDT+1
          DO K=1,NLAY
            TEXT='                '
            ILEN=LEN(TRIM(ADJUSTL(PREDNAME(N))))
            TEXT(1:ILEN) = PREDNAME(N)(1:ILEN)
            ! HEADER FOLLOWED BY ARRAY
            ! COULD LOAD TEMPORARY 2D ARRAY AND CALL 2D ARRAY WRITER INSTEAD OF THIS BUT IS THAT ANY BETTER?
            WRITE(IOUT,30) KSTP(NT),KPER(NT),K,TRIM(ADJUSTL(TEXT))
            IF(FILEFORMAT.EQ.'BINARY') WRITE(BINUNIT) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,K       !OR KSTP(NT),N,0.,1.0*REAL(N),TEXT,NCOL,NROW,K
            IF(FILEFORMAT.EQ.'BINARY') WRITE(BINUNIT) (PVARS(N,I),I=IGRDSEN,IGRDSEN+(NCOL*NROW)-1)
            IF(FILEFORMAT.EQ.'ASCII')  WRITE(BINUNIT,40) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,K    !OR KSTP(NT),N,0.,1.0*REAL(N),TEXT,NCOL,NROW,K
            IF(FILEFORMAT.EQ.'ASCII')  WRITE(BINUNIT,AFMT) (PVARS(N,I),I=IGRDSEN,IGRDSEN+(NCOL*NROW)-1)
            IF(FILEFORMAT.EQ.'TABLE')  WRITE(BINUNIT,40) KSTP(NT),KPER(NT),PERTIM(NT),TOTIM(NT),TEXT,NCOL,NROW,K    !OR KSTP(NT),N,0.,1.0*REAL(N),TEXT,NCOL,NROW,K
            IF(FILEFORMAT.EQ.'TABLE')  WRITE(BINUNIT,AFMT) (PVARS(N,I),I=IGRDSEN,IGRDSEN+(NCOL*NROW)-1)
            IGRDSEN=IGRDSEN+(NCOL*NROW)
          END DO
        END DO
      END DO
      CALL OPRPPR_OPENFILE(BINUNIT,2,OPRNODFNAM,IOUT)
      RETURN !OKAY
      END SUBROUTINE OPRPPR_WRITENOD

! --------------------------------------------

      SUBROUTINE OPRPPR_PVARSORT(IVC,PVARSUM,LOCNAME)
      ! INDEX SORT FINE FOR A FEW HUNDRED ENTRIES COULD IMPLEMENT BETTER ROUTINE
      USE UTILITIES, ONLY:             UTL_STOP
      USE GLOBAL_DATA, ONLY:           IVERB,LENDNAM
      USE OPR_PPR_VAR
      INTEGER                       :: IVC,IVC1,ITMP,N,I,ID(IVC)
      REAL                          :: PVARSUM(IVC),SORTED(IVC),XTMP
      CHARACTER(LEN=LENDNAM)        :: LOCNAME(IVC)
10    FORMAT(/,1X,64('-'),/,1X,'SUMMARY OF MOST AND LEAST IMPORTANT ',A,/,1X,64('-'))
20    FORMAT(/,1X,48('-'),/,1X,'SUMMARY OF MOST AND LEAST IMPORTANT ',A,/,1X,48('-'))
      ! REPORT MESSAGE
      IF(RUNMODE.EQ.'PPR') WRITE(IOUT,10) 'POTENTIAL NEW PARAMETER DATA'
	IF(RUNMODE.NE.'PPR') WRITE(IOUT,20) 'OBSERVATIONS'
      ! INITIALIZE
      DO I=1,IVC
        ID(I)=I
        SORTED(I)=PVARSUM(I)
      ENDDO
      IVC1=IVC-1
      ! FIRST LOOP, FIRST COLUMN
      DO N=IVC1,1,-1
        DO I=1,N
          IF(SORTED(I).GT.SORTED(I+1)) THEN
            XTMP=SORTED(I+1)
            SORTED(I+1)=SORTED(I)
            SORTED(I)=XTMP
            ITMP=ID(I+1)
            ID(I+1)=ID(I)
            ID(I)=ITMP
          ENDIF
        END DO
      ENDDO
      ! SORTED ARRAY COMPLETE. INDEX INDICATES ORIGINAL SORTING ORDER
      IF (IVC.LE.10) THEN ! LIST ALL
        DO N=1,IVC
          WRITE(IOUT,30) LOCNAME(ID(N)),SORTED(N)
30        FORMAT(1X,'OBS/GRP:',1X,A20,3X,'OPR-PPR:',1X,G12.6)
        END DO
      ELSE ! LIST TOP AND BOTTOM 5
        DO N=1,5
          WRITE(IOUT,40) LOCNAME(ID(N)),SORTED(N),LOCNAME(ID(IVC-N+1)),SORTED(IVC-N+1)
40        FORMAT(1X,A20,1X,G12.6,1X,'|',1X,A20,1X,G12.6)
        END DO
      END IF
      WRITE(IOUT,50)
50    FORMAT(/,1X,'NOTE: THIS TABLE IS CREATED BY SUMMING OPR OR PPR STATISTICS')
      RETURN !OKAY
      END SUBROUTINE OPRPPR_PVARSORT

! --------------------------------------------

      SUBROUTINE OPRPPR_INITWTMALL(WTMALL,WTM,NR,NNZ,MAXNEW)
      ! LOAD NEW CDMATRIX WITH ENTRIES FROM EXISTING CDMATRIX UP TO A
	  ! SPECIFIED DIAGONAL. AS WRITTEN ONLY WORKS FOR SQUARE MATRIX I.E. NR=NC
      ! ASSUMES NEW MATRIX AT LEAST AS LARGE AS OLD ONE (I.E. MAXNEW>=0)
      !   WTMALL = NEW CDMATRIX TO BE LOADED
      !   WTM    = EXISTING CDMATRIX
      !   NR=NC  = NUMBER OF ROWS/COLS OF EXISTING CDMATRIX
      !   MAXNEW = NUMBER OF ADDITIONAL ROWS/COLS IN NEW CDMATRIX
      !   NNZ    = NUMBER OF NON-ZERO ENTRIES IN EXISTING CDMATRIX
      USE DATATYPES
      USE UTILITIES, ONLY:             UTL_STOP,UTL_GETPOS,UTL_GETVAL
      USE GLOBAL_DATA, ONLY          : IVERB,MAX_STRING_LEN
      USE OPR_PPR_VAR, ONLY          : IOUT
      IMPLICIT NONE
      INTEGER                       :: IPOS,NR,NNZ,NNEW,IC,ICOLD,MAXNEW,N,M
      INTEGER(KIND=8)               :: IPOS8
      DOUBLE PRECISION              :: DUBVAL
      TYPE (CDMATRIX)               :: WTMALL,WTM
      NNEW=0
      WTMALL%NNZ = 0
      ICOLD = 0
      DO N=1,NR    !ROWS
        DO M=1,NR  !COLS
          IPOS = UTL_GETPOS(WTM,N,M)
          IF(IPOS.GE.1) THEN
            NNEW = NNEW + 1
            DUBVAL = UTL_GETVAL(WTM,N,M)
            IPOS8 = (INT(N,8)-1)*(INT(NR,8)+INT(MAXNEW,8))+INT(M,8)
            WTMALL%IPOS(NNEW) = IPOS8
            WTMALL%DVAL(NNEW) = DUBVAL
            IC = INT((IPOS8-1)/(INT(NR+MAXNEW,8)+1),4)
            WTMALL%NNZ = NNEW                               !WTMALL%NNZ = WTMALL%NNZ+1
            !write(*,*) 'NR: ',nr,'NNEW: ',nnew,'IPOS: ',ipos,'IPOS8: ',ipos8,'IC: ',ic
            IF (IC.NE.ICOLD) WTMALL%ICOL(IC) = NNEW
            ICOLD = IC
          END IF
        END DO
      END DO
      IF (NNEW.NE.NNZ) THEN
        WRITE(IOUT,10)
10      FORMAT(' ERROR: PROBLEM INITIALIZING NEW WEIGHT MATRIX - STOP (OPRPPR_INITWTMALL)')
        CALL UTL_STOP(' ')
      END IF
      RETURN
      END SUBROUTINE OPRPPR_INITWTMALL

! --------------------------------------------

      SUBROUTINE OPRPPR_PPRGRPS(NUMGPS,PARNAM,PARIND,IVC,OPRNAME,GRPNAME)
      ! IDENTIFY THE NUMGPS-GROUPS OF IPPERG-PARAMETERS FOR PPR ANALYSIS
      USE GLOBAL_DATA, ONLY          : LENDNAM
      USE OPR_PPR_VAR
      USE UTILITIES, ONLY            : UTL_NUM2CHAR
      IMPLICIT NONE
      INTEGER                :: NUMGPS,NG,NO,IVC,PARIND(IVC,NPPERG),IARRAY(NPPERG)
      CHARACTER(LEN=LENPNAM) :: PARNAM(NPERD)
      CHARACTER(LEN=LENDNAM) :: GRPNAME(NGC),OPRNAME(NGC,NGM),ADUM,AFMT,BFMT
      CHARACTER(LEN=3)       :: ANUMGPS
      LOGICAL                :: DONE
10    FORMAT(/,1X,'PARAMETER GROUPS FOR PPR STATISTIC:', &
             /,1X,'GROUP   GROUPNAME    MEMBERS   INDEXES ')
      DONE=.TRUE.
      WRITE(IOUT,10)
      DO NG=1,NUMGPS
        IF(RUNMODE.EQ.'PPR'.AND.PARGROUPS.EQ.'YES'.AND.NPPERG.EQ.1) THEN
          PARIND(NG,1)=NG
          OPRNAME(NG,1)=PARNAM(NG)
          GRPNAME(NG)=PARNAM(NG)
        ELSE
          CALL OPRPPR_COMBINATION(DONE,NPERD,NPPERG,IARRAY)
          ADUM='G '
          DO NO=1,NPPERG
            PARIND(NG,NO)=IARRAY(NO)
            OPRNAME(NG,NO)=PARNAM(IARRAY(NO))
            CALL UTL_NUM2CHAR(IARRAY(NO),ANUMGPS)
            IF(NO.NE.NPPERG) ADUM=TRIM(ADUM)//TRIM(ANUMGPS)//'_'
            IF(NO.EQ.NPPERG) ADUM=TRIM(ADUM)//TRIM(ANUMGPS)
          END DO
          !WRITE(ANUMGPS,'(I3)') NG
          !GRPNAME(NG)='GROUP'//TRIM(ADJUSTL(ANUMGPS))
          GRPNAME(NG)=ADUM
        ENDIF
        ! BUILD THE OUTPUT FORMAT BEFORE WRITING
        CALL OPRPPR_BLDFMT(AFMT,'A',NPPERG,LENDNAM,0)
        CALL OPRPPR_BLDFMT(BFMT,'I',NPPERG,5,0)
        WRITE(IOUT,'(I5,2X,'//'A20,'//TRIM(AFMT)//','//TRIM(BFMT)//')') &
              NG,GRPNAME(NG),(OPRNAME(NG,NO),NO=1,NPPERG),(PARIND(NG,NO),NO=1,NPPERG)
      END DO
      RETURN !OKAY
      END SUBROUTINE OPRPPR_PPRGRPS

!---------------------------------------------

      SUBROUTINE OPRPPR_COMBINATION(DONE,N,K,IARRAY)
      ! COMPUTE COMBINATIONS - SEQUENTIAL & LEXICOGRAPHIC - OF K THINGS FROM N THINGS
      ! REF: CHARLES MIFSUD,COMBINATION IN LEXICOGRAPHIC ORDER,ACM ALGORITHM 154,MARCH 1963
      ! MODIFIED (2005) AFTER: COMB_NEXT (CHARLES MIFSUD) AND IVEC_IDENTITY (JOHN BURKARDT)
      IMPLICIT NONE
      INTEGER  :: K,I,J,N,IARRAY(K)
      LOGICAL  :: DONE
      IF (DONE) THEN
        DO I = 1, K
          IARRAY(I) = I
        END DO
        IF (K > 1) DONE = .FALSE.
      ELSE
        IF (IARRAY(K) < N) THEN
          IARRAY(K) = IARRAY(K) + 1
          RETURN
        END IF
        DO I = K, 2, -1
          IF (IARRAY(I-1) < N-K+I-1) THEN
            IARRAY(I-1) = IARRAY(I-1) + 1
            DO J = I, K
              IARRAY(J) = IARRAY(I-1) + J - (I-1)
            END DO
            RETURN
          END IF
        END DO
        DONE = .TRUE.
      END IF
      RETURN
      END SUBROUTINE OPRPPR_COMBINATION

! ----------------------------------------------------------------------

      SUBROUTINE OPRPPR_CHECKPAR(IOUT,NPERD,PARNAM,PARNAMD,FNAM1,FNAM2,IINDEX)
      USE UTILITIES, ONLY:      UTL_SAMENAME,UTL_STOP
      USE OPR_PPR_VAR, ONLY:    NPARPREDONLY
      IMPLICIT NONE
      INTEGER                :: NPE,NPERD,J,IOUT,LENPNAM,I,IINDEX
      CHARACTER(LEN=*)       :: FNAM1,FNAM2
      PARAMETER(LENPNAM=12)
      CHARACTER(LEN=LENPNAM) :: PARNAM(NPERD),PARNAMD(NPERD)
	LOGICAL                :: FOUND
	! THIS CHECK DOES NOT CARE ABOUT ORDER OC OCCURENCE JUST PRESENCE
	DO I=1,IINDEX
	  FOUND=.FALSE.
        DO J=1,IINDEX
          IF(UTL_SAMENAME(PARNAM(I),PARNAMD(J))) FOUND =.TRUE.
	  END DO
	  IF(.NOT.FOUND)THEN
          WRITE(IOUT,5)
    5     FORMAT(/,1X,'ERROR:')
          WRITE(IOUT,10) TRIM(FNAM1),TRIM(PARNAM(J)),TRIM(FNAM2),TRIM(PARNAMD(J))
   10     FORMAT(/,1X,'PARNAM READ FROM ',A,' - ',A, &
                 /,1X,'DIFFERS FROM',                &
                 /,1X,'PARNAM READ FROM ',A,' - ',A)
          CALL UTL_STOP(' STOP: ERROR MATCHING PARAMETER NAMES')
	  END IF
      END DO
      RETURN
      END SUBROUTINE OPRPPR_CHECKPAR

! --------------------------------------------

      SUBROUTINE OPRPPR_OPENFILE(IFILE,INTEND,FNAM,IOUT)
      ! FNAM   = FILE NAME
      ! IFILE  = UNIT NUMBER
      ! IOUT   = UNIT NUMBER TO REPORT MESSAGES/ERRORS/PROGRESS
      ! INTEND = 1: OPEN EXISTING ASCII
      ! INTEND = 2: CLOSE EXISTING FILE
      ! INTEND = 3: OPEN UNKNOWN ASCII
      ! INTEND = 4: OPEN UNKNOWN BINARY USING "FORM='BINARY'"
      ! INTEND = 5: OPEN EXISTING BINARY USING "FORM='BINARY'"
      IMPLICIT NONE
      CHARACTER(LEN=*) :: FNAM
      LOGICAL          :: TESTFL,LOP
      INTEGER          :: INTEND,IFILE,IERR,MAXUNIT,N,IOUT
      PARAMETER(MAXUNIT = 100)
      ! TEST FOR EXISTING FILES
      INQUIRE(FILE=FNAM,EXIST=TESTFL)
      IF(.NOT.TESTFL) THEN
        IF (INTEND.EQ.1.OR.INTEND.EQ.2.OR.INTEND.EQ.5) THEN
          WRITE(*,10) TRIM(ADJUSTL(FNAM))
          STOP
        END IF
      ENDIF
      IF (INTEND.EQ.1) OPEN(IFILE,FILE=FNAM,STATUS='OLD',IOSTAT=IERR)
      IF (INTEND.EQ.2) CLOSE(IFILE,IOSTAT=IERR)
      IF (INTEND.EQ.3) OPEN(IFILE,FILE=FNAM,STATUS='UNKNOWN',IOSTAT=IERR)
!swm      IF (INTEND.EQ.4) OPEN(IFILE,FILE=FNAM,STATUS='UNKNOWN',FORM='BINARY',IOSTAT=IERR)
      IF (INTEND.EQ.4) OPEN(IFILE,FILE=FNAM,STATUS='UNKNOWN',FORM='UNFORMATTED',IOSTAT=IERR)
!swm      IF (INTEND.EQ.5) OPEN(IFILE,FILE=FNAM,STATUS='OLD',FORM='BINARY',IOSTAT=IERR)
      IF (INTEND.EQ.5) OPEN(IFILE,FILE=FNAM,STATUS='OLD',FORM='UNFORMATTED',IOSTAT=IERR)
      ! REPORT
      IF (INTEND.NE.2)THEN
        IF(IERR.NE.0) THEN
          WRITE(IOUT,20) 'OPENING',TRIM(ADJUSTL(FNAM))
        ELSE
          WRITE(IOUT,30) 'OPENED',TRIM(ADJUSTL(FNAM))
        END IF
      ELSE
        IF(IERR.NE.0) THEN
          WRITE(IOUT,20) 'CLOSING',TRIM(ADJUSTL(FNAM))
        ELSE
          WRITE(IOUT,30) 'CLOSED',TRIM(ADJUSTL(FNAM))
        END IF
      END IF
      ! IF ERROR CLOSE OPEN FILES W/ UNIT NO. UP TO MAXUNIT AND STOP
      IF (IERR.NE.0) THEN
        DO N=1,MAXUNIT
          INQUIRE(UNIT=N,OPENED=LOP)
          IF (LOP) CLOSE(N)
        END DO
        STOP
      END IF
      ! RETURN IF ALL OKAY
      RETURN
10    FORMAT(/,1X,' ERROR: FILE ',A,' DOES NOT EXIST')
20    FORMAT(/,1X,' ERROR: PROBLEM ',A,' FILE ',A)
30    FORMAT(1X,'SUCCESSFULLY ',A,' FILE ',A)
      END SUBROUTINE OPRPPR_OPENFILE

! --------------------------------------------

      LOGICAL FUNCTION ALLOCATEERROR(IOUT,IERR,ARYNAME)
      ! RETURN ERROR IF ALLOCATION OF AN ARRAY FAILED
      !   IOUT    = UNIT TO WRITE ERROR TO
      !   IERR    = STORED STAT FLAG RETURNED FROM ALLOCATION
      !   ARYNAME = NAME(S) OF THE ARRAY(S) WHERE FAILURE OCCURED
      IMPLICIT NONE
      CHARACTER(LEN=*) ARYNAME
      INTEGER IERR,IOUT
      ALLOCATEERROR=.FALSE.
      IF (IERR.NE.0) THEN
          ALLOCATEERROR=.TRUE.
          WRITE(IOUT,*) 'ERROR: PROBLEM ENCOUNTERED ALLOCATING MEMORY: ',ARYNAME
      ENDIF
      END FUNCTION ALLOCATEERROR

! --------------------------------------------

      INTEGER(KIND=8) FUNCTION NFACT(IVAL)
      ! FACTORIAL OF A NUMBER WHERE IVAL<=20
      IMPLICIT NONE
      INTEGER N,IVAL
      IF(IVAL.EQ.1)NFACT=1
      IF(IVAL.GT.1)THEN
        NFACT=IVAL
        DO N=IVAL-1,1,-1
          NFACT=NFACT*N
        END DO
      END IF
      END FUNCTION NFACT

! --------------------------------------------

      DOUBLE PRECISION FUNCTION RFACT(IVAL)
      ! FACTORIAL OF A NUMBER WHERE IVAL>=21
      IMPLICIT NONE
      INTEGER N,IVAL
      IF(IVAL.EQ.1)RFACT=1.0D0
      IF(IVAL.GT.1)THEN
        RFACT=DBLE(IVAL)
        DO N=IVAL-1,1,-1
          RFACT=RFACT*DBLE(N)
        END DO
      END IF
      END FUNCTION RFACT

! --------------------------------------------

      INTEGER FUNCTION NUMNONZ(WTM,NR,NC) RESULT (NNZ)
      ! DETERMINE NUMBER OF NON-ZERO ENTRIES IN AN EXISTING CDMATRIX:
      !   WTM    = EXISTING CDMATRIX
      !   NR     = NUMBER OF ROWS OF CDMATRIX WTM
      !   NC     = NUMBER OF COLS OF CDMATRIX WTM
      !   NNZ    = NUMBER OF NON-ZERO ENTRIES IN CDMATRIX WTM
      USE DATATYPES
      USE UTILITIES, ONLY:             UTL_GETPOS,UTL_GETVAL
      IMPLICIT NONE
      INTEGER                       :: NR,NC,N,M,IPOS
      TYPE (CDMATRIX)               :: WTM
      NNZ=1
      DO N=1,NR
        DO M=1,NC
          IPOS = UTL_GETPOS(WTM,N,M)
          IF(IPOS.GT.1) NNZ=NNZ+1
        END DO
      END DO
      END FUNCTION NUMNONZ

!-----------------------------------------------------------------------

      SUBROUTINE OPRPPR_WRITEMATRIX(IOUTFILE,NUMROWS,NUMCOLS,ROWNAMES,COLNAMES,REALARRAY)
      ! WRITE MATRIX TO A FILE
      USE GLOBAL_DATA, ONLY: NPPREC
      IMPLICIT NONE
      INTEGER,                              INTENT(IN) :: IOUTFILE             ! Unit number
      INTEGER,                              INTENT(IN) :: NUMROWS              ! Number of ROWS
      INTEGER,                              INTENT(IN) :: NUMCOLS              ! Number of COLUMNS
      CHARACTER(LEN=*), DIMENSION(NUMROWS), INTENT(IN) :: ROWNAMES             ! ROW NAMES
      CHARACTER(LEN=*), DIMENSION(NUMCOLS), INTENT(IN) :: COLNAMES             ! COLUMN NAMES
      DOUBLE PRECISION, DIMENSION(NUMCOLS,NUMROWS), INTENT(IN) :: REALARRAY    ! ARRAY
      CHARACTER(LEN=100)                               :: FMT_STRING1, FMT_STRING2
      CHARACTER(LEN=10)                                :: STR_NPPREC,AILEN,GCHAR,ANP
      CHARACTER(LEN=1)                                 :: QUOTE
      INTEGER                                          :: KP,KB,IP,IP1,IP2,N,NP,ILEN
      KP=0
      KB=0
      NP=0
      ! CONSTRUCT FORMAT STRINGS
      QUOTE='"'
      ILEN=LEN(COLNAMES(1))
      NP=INT(ILEN/2)
      WRITE(ANP,'(I10)') NP
      WRITE(AILEN,'(I10)') ILEN
      AILEN=ADJUSTL(AILEN)
      AILEN(2:10)=AILEN(1:9)
      AILEN(1:1)='A'
      WRITE(STR_NPPREC,'(I10)') NPPREC
      STR_NPPREC = ADJUSTL(STR_NPPREC)
      FMT_STRING1 = '(1X,''"ROWNAME     " '','//'T25,'//TRIM(STR_NPPREC)// &
                    '(2X,''"'','//TRIM(AILEN)//',''"'',:))'
      GCHAR='            '
      GCHAR='G'//TRIM(ADJUSTL(AILEN(2:10)))
      GCHAR=TRIM(ADJUSTL(GCHAR))//'.'//TRIM(ADJUSTL(ANP))
      FMT_STRING2 = '(1X,A,T25,'//TRIM(STR_NPPREC)//'(4X,'//TRIM(ADJUSTL(GCHAR))//'))'//')'    !crt added //')' to end of line
!swm      FMT_STRING2 = '(1X,A,T25,'//TRIM(STR_NPPREC)//'(4X,'//TRIM(ADJUSTL(GCHAR))//')'
!crt      FMT_STRING2 = '(1X,A,T25,'//TRIM(STR_NPPREC)//'(4X,'//TRIM(ADJUSTL(GCHAR))//'))' !swm: added final parenthesis
      ! WRITE MATRIX IN BLOCKS OF NPPREC COLUMNS
      BLOK: DO WHILE (KP<NUMCOLS)
        IP1 = KB*NPPREC+1
        KB = KB+1
        IP2 = KB*NPPREC
        IF (IP2>NUMCOLS) IP2 = NUMCOLS
        WRITE (IOUTFILE,FMT_STRING1) (COLNAMES(IP),IP=IP1,IP2)
        DO N = 1, NUMROWS
          WRITE (IOUTFILE,FMT_STRING2) ROWNAMES(N),(REALARRAY(IP,N),IP=IP1,IP2)
        END DO
        KP = IP2
      ENDDO BLOK
      RETURN
      END SUBROUTINE OPRPPR_WRITEMATRIX

!-----------------------------------------------------------------------

      SUBROUTINE OPRPPR_BLDFMT(CLINE,ACH,INUM,ILEN,IPREC)
      USE UTILITIES, ONLY             : UTL_STOP, UTL_CASE
      IMPLICIT NONE
      INTEGER                        :: IFAIL,ILEN,IPREC,INUM
      CHARACTER(LEN=1)               :: ACH,ACHUP
      CHARACTER(LEN=20)              :: AFMT,AITN
      CHARACTER*(*)                  :: CLINE
      IFAIL=0
      CALL UTL_CASE(ACH,ACHUP,1)
      ! CHECK SOME THINGS
      IF(ACH.EQ.'E'.AND.IPREC.GT.ILEN-1) CALL UTL_STOP('ERROR IN FORMAT STATEMENT (OPRPPR_BLDFMT)')
      IF(ACH.EQ.'G'.AND.IPREC.GT.ILEN-1) CALL UTL_STOP('ERROR IN FORMAT STATEMENT (OPRPPR_BLDFMT)')
      ! BUILD STATEMENT
!swm      WRITE(AITN,'(I)') INUM
      WRITE(AITN,'(I0)') INUM
      AFMT='('//TRIM(ADJUSTL(AITN))
      AFMT=TRIM(ADJUSTL(AFMT))//ACHUP
      IF(ACH.EQ.'A'.OR.ACH.EQ.'I') THEN
!swm         WRITE(AITN,'(I)') ILEN
         WRITE(AITN,'(I0)') ILEN
         AFMT=TRIM(ADJUSTL(AFMT))//TRIM(ADJUSTL(AITN))//')'
         CLINE(1:20)=AFMT
         RETURN
      END IF
      IF(ACH.EQ.'E'.OR.ACH.EQ.'G'.OR.ACH.EQ.'F') THEN
!swm         WRITE(AITN,'(I)') ILEN
         WRITE(AITN,'(I0)') ILEN
         AFMT=TRIM(ADJUSTL(AFMT))//TRIM(ADJUSTL(AITN))//'.'
!swm         WRITE(AITN,'(I)') IPREC
         WRITE(AITN,'(I0)') IPREC
         AFMT=TRIM(ADJUSTL(AFMT))//TRIM(ADJUSTL(AITN))//')'
         CLINE(1:20)=AFMT
         RETURN
      END IF
      CALL UTL_STOP('ERROR IN FORMAT STATEMENT (OPRPPR_BLDFMT)')
      END SUBROUTINE OPRPPR_BLDFMT
